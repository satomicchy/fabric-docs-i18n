# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the
# hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-19 19:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/policies.rst:2
msgid "Policies in Hyperledger Fabric"
msgstr ""

#: ../../source/policies.rst:4
msgid ""
"Configuration for a Hyperledger Fabric blockchain network is managed by "
"policies. These policies generally reside in the channel configuration. "
"The primary purpose of this document is to explain how policies are "
"defined in and interact with the channel configuration. However, policies"
" may also be specified in some other places, such as chaincodes, so this "
"information may be of interest outside the scope of channel "
"configuration."
msgstr ""

#: ../../source/policies.rst:13
msgid "What is a Policy?"
msgstr ""

#: ../../source/policies.rst:15
msgid ""
"At its most basic level, a policy is a function which accepts as input a "
"set of signed data and evaluates successfully, or returns an error "
"because some aspect of the signed data did not satisfy the policy."
msgstr ""

#: ../../source/policies.rst:19
msgid ""
"More concretely, policies test whether the signer or signers of some data"
" meet some condition required for those signatures to be considered "
"'valid'. This is useful for determining that the correct parties have "
"agreed to a transaction, or change."
msgstr ""

#: ../../source/policies.rst:24
msgid "For example a policy may define any of the following:"
msgstr ""

#: ../../source/policies.rst:26
msgid "Administrators from 2 out 5 possible different organizations must sign."
msgstr ""

#: ../../source/policies.rst:27
msgid "Any member from any organization must sign."
msgstr ""

#: ../../source/policies.rst:28
msgid "Two specific certificates must both sign."
msgstr ""

#: ../../source/policies.rst:30
msgid ""
"Of course these are only examples, and other more powerful rules can be "
"constructed."
msgstr ""

#: ../../source/policies.rst:34
msgid "Policy Types"
msgstr ""

#: ../../source/policies.rst:36
msgid "There are presently two different types of policies implemented:"
msgstr ""

#: ../../source/policies.rst:38
msgid ""
"**SignaturePolicy**: This policy type is the most powerful, and specifies"
" the policy as a combination of evaluation rules for MSP Principals. It "
"supports arbitrary combinations of *AND*, *OR*, and *NOutOf*, allowing "
"the construction of extremely powerful rules like: \"An admin of org A "
"and 2 other admins, or 11 of 20 org admins\"."
msgstr ""

#: ../../source/policies.rst:43
msgid ""
"**ImplicitMetaPolicy**: This policy type is less flexible than "
"SignaturePolicy, and is only valid in the context of configuration. It "
"aggregates the result of evaluating policies deeper in the configuration "
"hierarchy, which are ultimately defined by SignaturePolicies. It supports"
" good default rules like \"A majority of the organization admin "
"policies\"."
msgstr ""

#: ../../source/policies.rst:50
msgid ""
"Policies are encoded in a ``common.Policy`` message as defined in "
"``fabric-protos/common/policies.proto``. They are defined by the "
"following message:"
msgstr ""

#: ../../source/policies.rst:67
msgid ""
"To encode the policy, simply pick the policy type of either ``SIGNATURE``"
" or ``IMPLICIT_META``, set it to the ``type`` field, and marshal the "
"corresponding policy implementation proto to ``policy``."
msgstr ""

#: ../../source/policies.rst:72
msgid "Configuration and Policies"
msgstr ""

#: ../../source/policies.rst:74
msgid ""
"The channel configuration is expressed as a hierarchy of configuration "
"groups, each of which has a set of values and policies associated with "
"them. For a validly configured application channel with two application "
"organizations and one ordering organization, the configuration looks "
"minimally as follows:"
msgstr ""

#: ../../source/policies.rst:116
msgid ""
"Consider the Writers policy referred to with the ``------->`` mark in the"
" above example. This policy may be referred to by the shorthand notation "
"``/Channel/Application/Writers``. Note that the elements resembling "
"directory components are group names, while the last component resembling"
" a file basename is the policy name."
msgstr ""

#: ../../source/policies.rst:122
msgid ""
"Different components of the system will refer to these policy names. For "
"instance, to call ``Deliver`` on the orderer, the signature on the "
"request must satisfy the ``/Channel/Readers`` policy. However, to gossip "
"a block to a peer will require that the ``/Channel/Application/Readers`` "
"policy be satisfied."
msgstr ""

#: ../../source/policies.rst:128
msgid ""
"By setting these different policies, the system can be configured with "
"rich access controls."
msgstr ""

#: ../../source/policies.rst:132
msgid "Constructing a SignaturePolicy"
msgstr ""

#: ../../source/policies.rst:134
msgid "As with all policies, the SignaturePolicy is expressed as protobuf."
msgstr ""

#: ../../source/policies.rst:155
msgid ""
"The outer ``SignaturePolicyEnvelope`` defines a version (currently only "
"``0`` is supported), a set of identities expressed as ``MSPPrincipal``\\ "
"s , and a ``policy`` which defines the policy rule, referencing the "
"``identities`` by index. For more details on how to specify MSP "
"Principals, see the MSP Principals section."
msgstr ""

#: ../../source/policies.rst:161
msgid ""
"The ``SignaturePolicy`` is a recursive data structure which either "
"represents a single signature requirement from a specific "
"``MSPPrincipal``, or a collection of ``SignaturePolicy``\\ s, requiring "
"that ``N`` of them are satisfied."
msgstr ""

#: ../../source/policies.rst:166
msgid "For example:"
msgstr ""

#: ../../source/policies.rst:184
msgid ""
"This defines a signature policy over MSP Principals ``mspP1`` and "
"``mspP2``. It requires both that there is a signature satisfying "
"``mspP1`` and a signature satisfying ``mspP2``."
msgstr ""

#: ../../source/policies.rst:188
msgid "As another more complex example:"
msgstr ""

#: ../../source/policies.rst:214
msgid ""
"This defines a signature policy over MSP Principals ``mspP1``, ``mspP2``,"
" and ``mspP3``. It requires one signature which satisfies ``mspP1``, and "
"another signature which either satisfies ``mspP2`` or ``mspP3``."
msgstr ""

#: ../../source/policies.rst:219
msgid ""
"Hopefully it is clear that complicated and relatively arbitrary logic may"
" be expressed using the SignaturePolicy policy type. For code which "
"constructs signature policies, consult "
"``fabric/common/cauthdsl/cauthdsl_builder.go``."
msgstr ""

#: ../../source/policies.rst:226
msgid ""
"**Limitations**: When evaluating a signature policy against a signature "
"set, signatures are 'consumed', in the order in which they appear, "
"regardless of whether they satisfy multiple policy principals."
msgstr ""

#: ../../source/policies.rst:230
msgid "For example.  Consider a policy which requires"
msgstr ""

#: ../../source/policies.rst:236
msgid ""
"The naive intent of this policy is to require that both an admin, and a "
"member sign. For the signature set"
msgstr ""

#: ../../source/policies.rst:243
msgid ""
"the policy evaluates to true, just as expected.  However, consider the "
"signature set"
msgstr ""

#: ../../source/policies.rst:250
msgid ""
"This signature set does not satisfy the policy.  This failure is because "
"when ``org1.AdminSignature`` satisfies the ``org1.Member`` role it is "
"considered 'consumed' by the ``org1.Member`` requirement.  Because the "
"``org1.Admin`` principal cannot be satisfied by the "
"``org1.MemberSignature``, the policy evaluates to false."
msgstr ""

#: ../../source/policies.rst:256
msgid ""
"To avoid this pitfall, identities should be specified from most "
"privileged to least privileged in the policy identities specification, "
"and signatures should be ordered from least privileged to most privileged"
" in the signature set."
msgstr ""

#: ../../source/policies.rst:261
msgid "MSP Principals"
msgstr ""

#: ../../source/policies.rst:263
msgid ""
"The MSP Principal is a generalized notion of cryptographic identity. "
"Although the MSP framework is designed to work with types of cryptography"
" other than X.509, for the purposes of this document, the discussion will"
" assume that the underlying MSP implementation is the default MSP type, "
"based on X.509 cryptography."
msgstr ""

#: ../../source/policies.rst:269
msgid ""
"An MSP Principal is defined in ``fabric-protos/msp_principal.proto`` as "
"follows:"
msgstr ""

#: ../../source/policies.rst:287
msgid ""
"The ``principal_classification`` must be set to either ``ROLE`` or "
"``IDENTITY``. The ``ORGANIZATIONAL_UNIT`` is at the time of this writing "
"not implemented."
msgstr ""

#: ../../source/policies.rst:291
msgid ""
"In the case of ``IDENTITY`` the ``principal`` field is set to the bytes "
"of a certificate literal."
msgstr ""

#: ../../source/policies.rst:294
msgid ""
"However, more commonly the ``ROLE`` type is used, as it allows the "
"principal to match many different certs issued by the MSP's certificate "
"authority."
msgstr ""

#: ../../source/policies.rst:298
msgid ""
"In the case of ``ROLE``, the ``principal`` is a marshaled ``MSPRole`` "
"message defined as follows:"
msgstr ""

#: ../../source/policies.rst:316
msgid ""
"The ``msp_identifier`` is set to the ID of the MSP (as defined by the "
"``MSPConfig`` proto in the channel configuration for an org) which will "
"evaluate the signature, and the ``Role`` is set to either ``MEMBER``, "
"``ADMIN``, ``CLIENT`` or ``PEER``. In particular:"
msgstr ""

#: ../../source/policies.rst:321
msgid "``MEMBER`` matches any certificate issued by the MSP."
msgstr ""

#: ../../source/policies.rst:322
msgid "``ADMIN`` matches certificates enumerated as admin in the MSP definition."
msgstr ""

#: ../../source/policies.rst:323
msgid ""
"``CLIENT`` (``PEER``) matches certificates that carry the client (peer) "
"Organizational unit."
msgstr ""

#: ../../source/policies.rst:325
msgid ""
"(see `MSP Documentation <http://hyperledger-"
"fabric.readthedocs.io/en/latest/msp.html>`_)"
msgstr ""

#: ../../source/policies.rst:328
msgid "Constructing an ImplicitMetaPolicy"
msgstr ""

#: ../../source/policies.rst:330
msgid ""
"The ``ImplicitMetaPolicy`` is only validly defined in the context of "
"channel configuration. It is ``Implicit`` because it is constructed "
"implicitly based on the current configuration, and it is ``Meta`` because"
" its evaluation is not against MSP principals, but rather against other "
"policies. It is defined in ``fabric-protos/common/policies.proto`` as "
"follows:"
msgstr ""

#: ../../source/policies.rst:349
msgid "For example, consider a policy defined at ``/Channel/Readers`` as"
msgstr ""

#: ../../source/policies.rst:358
msgid ""
"This policy will implicitly select the sub-groups of ``/Channel``, in "
"this case, ``Application`` and ``Orderer``, and retrieve the policy of "
"name ``foo``, to give the policies ``/Channel/Application/foo`` and "
"``/Channel/Orderer/foo``. Then, when the policy is evaluated, it will "
"check to see if ``ANY`` of those two policies evaluate without error. Had"
" the rule been ``ALL`` it would require both."
msgstr ""

#: ../../source/policies.rst:365
msgid ""
"Consider another policy defined at ``/Channel/Application/Writers`` where"
" there are 3 application orgs defined, ``OrgA``, ``OrgB``, and ``OrgC``."
msgstr ""

#: ../../source/policies.rst:376
msgid ""
"In this case, the policies collected would be "
"``/Channel/Application/OrgA/bar``, ``/Channel/Application/OrgB/bar``, and"
" ``/Channel/Application/OrgC/bar``. Because the rule requires a "
"``MAJORITY``, this policy will require that 2 of the three organization's"
" ``bar`` policies are satisfied."
msgstr ""

#: ../../source/policies.rst:383
msgid "Policy Defaults"
msgstr ""

#: ../../source/policies.rst:385
msgid ""
"The ``configtxgen`` tool uses policies which must be specified explicitly"
" in configtx.yaml."
msgstr ""

#: ../../source/policies.rst:387
msgid ""
"Note that policies higher in the hierarchy are all defined as "
"``ImplicitMetaPolicy``\\ s while leaf nodes necessarily are defined as "
"``SignaturePolicy``\\ s. This set of defaults works nicely because the "
"``ImplicitMetaPolicies`` do not need to be redefined as the number of "
"organizations change, and the individual organizations may pick their own"
" rules and thresholds for what is means to be a Reader, Writer, and "
"Admin."
msgstr ""

#: ../../source/policies/policies.md:1
msgid "# Policies"
msgstr ""

#: ../../source/policies/policies.md:3
msgid ""
"**Audience**: Architects, application and smart contract developers, "
"administrators"
msgstr ""

#: ../../source/policies/policies.md:6
msgid "In this topic, we'll cover:"
msgstr ""

#: ../../source/policies/policies.md:8
msgid "[What is a policy](#what-is-a-policy)"
msgstr ""

#: ../../source/policies/policies.md:9
msgid "[Why are policies needed](#why-are-policies-needed)"
msgstr ""

#: ../../source/policies/policies.md:10
msgid ""
"[How are policies implemented throughout Fabric](#how-are-policies-"
"implemented-throughout-fabric)"
msgstr ""

#: ../../source/policies/policies.md:11
msgid "[Fabric policy domains](#the-fabric-policy-domains)"
msgstr ""

#: ../../source/policies/policies.md:12
msgid ""
"[How do you write a policy in Fabric](#how-do-you-write-a-policy-in-"
"fabric)"
msgstr ""

#: ../../source/policies/policies.md:13
msgid "[Fabric chaincode lifecycle](#fabric-chaincode-lifecycle)"
msgstr ""

#: ../../source/policies/policies.md:14
msgid "[Overriding policy definitions](#overriding-policy-definitions)"
msgstr ""

#: ../../source/policies/policies.md:16
msgid "## What is a policy"
msgstr ""

#: ../../source/policies/policies.md:18
msgid ""
"At its most basic level, a policy is a set of rules that define the "
"structure for how decisions are made and specific outcomes are reached. "
"To that end, policies typically describe a **who** and a **what**, such "
"as the access or rights that an individual has over an **asset**. We can "
"see that policies are used throughout our daily lives to protect assets "
"of value to us, from car rentals, health, our homes, and many more."
msgstr ""

#: ../../source/policies/policies.md:25
msgid ""
"For example, an insurance policy defines the conditions, terms, limits, "
"and expiration under which an insurance payout will be made. The policy "
"is agreed to by the policy holder and the insurance company, and defines "
"the rights and responsibilities of each party."
msgstr ""

#: ../../source/policies/policies.md:30
msgid ""
"Whereas an insurance policy is put in place for risk management, in "
"Hyperledger Fabric, policies are the mechanism for infrastructure "
"management. Fabric policies represent how members come to agreement on "
"accepting or rejecting changes to the network, a channel, or a smart "
"contract. Policies are agreed to by the consortium members when a network"
" is originally configured, but they can also be modified as the network "
"evolves. For example, they describe the criteria for adding or removing "
"members from a channel, change how blocks are formed, or specify the "
"number of organizations required to endorse a smart contract. All of "
"these actions are described by a policy which defines who can perform the"
" action. Simply put, everything you want to do on a Fabric network is "
"controlled by a policy."
msgstr ""

#: ../../source/policies/policies.md:42
msgid "## Why are policies needed"
msgstr ""

#: ../../source/policies/policies.md:44
msgid ""
"Policies are one of the things that make Hyperledger Fabric different "
"from other blockchains like Ethereum or Bitcoin. In those systems, "
"transactions can be generated and validated by any node in the network. "
"The policies that govern the network are fixed at any point in time and "
"can only be changed using the same process that governs the code. Because"
" Fabric is a permissioned blockchain whose users are recognized by the "
"underlying infrastructure, those users have the ability to decide on the "
"governance of the network before it is launched, and change the "
"governance of a running network."
msgstr ""

#: ../../source/policies/policies.md:53
msgid ""
"Policies allow members to decide which organizations can access or update"
" a Fabric network, and provide the mechanism to enforce those decisions. "
"Policies contain the lists of organizations that have access to a given "
"resource, such as a user or system chaincode. They also specify how many "
"organizations need to agree on a proposal to update a resource, such as a"
" channel or smart contracts. Once they are written, policies evaluate the"
" collection of signatures attached to transactions and proposals and "
"validate if the signatures fulfill the governance agreed to by the "
"network."
msgstr ""

#: ../../source/policies/policies.md:62
msgid "## How are policies implemented throughout Fabric"
msgstr ""

#: ../../source/policies/policies.md:64
msgid ""
"Policies are implemented at different levels of a Fabric network. Each "
"policy domain governs different aspects of how a network operates."
msgstr ""

#: ../../source/policies/policies.md:67
msgid ""
"![policies.policies](./FabricPolicyHierarchy-2.png) *A visual "
"representation of the Fabric policy hierarchy.*"
msgstr ""

#: ../../source/policies/policies.md:70
msgid "### System channel configuration"
msgstr ""

#: ../../source/policies/policies.md:72
msgid ""
"Every network begins with an ordering **system channel**. There must be "
"exactly one ordering system channel for an ordering service, and it is "
"the first channel to be created. The system channel also contains the "
"organizations who are the members of the ordering service (ordering "
"organizations) and those that are on the networks to transact (consortium"
" organizations)."
msgstr ""

#: ../../source/policies/policies.md:78
msgid ""
"The policies in the ordering system channel configuration blocks govern "
"the consensus used by the ordering service and define how new blocks are "
"created. The system channel also governs which members of the consortium "
"are allowed to create new channels."
msgstr ""

#: ../../source/policies/policies.md:83
msgid "### Application channel configuration"
msgstr ""

#: ../../source/policies/policies.md:85
msgid ""
"Application _channels_ are used to provide a private communication "
"mechanism between organizations in the consortium."
msgstr ""

#: ../../source/policies/policies.md:88
msgid ""
"The policies in an application channel govern the ability to add or "
"remove members from the channel. Application channels also govern which "
"organizations are required to approve a chaincode before the chaincode is"
" defined and committed to a channel using the Fabric chaincode lifecycle."
" When an application channel is initially created, it inherits all the "
"ordering service parameters from the orderer system channel by default. "
"However, those parameters (and the policies governing them) can be "
"customized in each channel."
msgstr ""

#: ../../source/policies/policies.md:96
msgid "### Access control lists (ACLs)"
msgstr ""

#: ../../source/policies/policies.md:98
msgid ""
"Network administrators will be especially interested in the Fabric use of"
" ACLs, which provide the ability to configure access to resources by "
"associating those resources with existing policies. These \"resources\" "
"could be functions on system chaincode (e.g., \"GetBlockByNumber\" on the"
" \"qscc\" system chaincode) or other resources (e.g.,who can receive "
"Block events). ACLs refer to policies defined in an application channel "
"configuration and extends them to control additional resources. The "
"default set of Fabric ACLs is visible in the `configtx.yaml` file under "
"the `Application: &ApplicationDefaults` section but they can and should "
"be overridden in a production environment. The list of resources named in"
" `configtx.yaml` is the complete set of all internal resources currently "
"defined by Fabric."
msgstr ""

#: ../../source/policies/policies.md:110
msgid "In that file, ACLs are expressed using the following format:"
msgstr ""

#: ../../source/policies/policies.md:112
msgid ""
"``` # ACL policy for chaincode to chaincode invocation "
"peer/ChaincodeToChaincode: /Channel/Application/Readers ```"
msgstr ""

#: ../../source/policies/policies.md:117
msgid ""
"Where `peer/ChaincodeToChaincode` represents the resource being secured "
"and `/Channel/Application/Readers` refers to the policy which must be "
"satisfied for the associated transaction to be considered valid."
msgstr ""

#: ../../source/policies/policies.md:121
msgid ""
"For a deeper dive into ACLS, refer to the topic in the Operations Guide "
"on [ACLs](../access_control.html)."
msgstr ""

#: ../../source/policies/policies.md:123
msgid "### Smart contract endorsement policies"
msgstr ""

#: ../../source/policies/policies.md:125
msgid ""
"Every smart contract inside a chaincode package has an endorsement policy"
" that specifies how many peers belonging to different channel members "
"need to execute and validate a transaction against a given smart contract"
" in order for the transaction to be considered valid. Hence, the "
"endorsement policies define the organizations (through their peers) who "
"must “endorse” (i.e., approve of) the execution of a proposal."
msgstr ""

#: ../../source/policies/policies.md:132
msgid "### Modification policies"
msgstr ""

#: ../../source/policies/policies.md:134
msgid ""
"There is one last type of policy that is crucial to how policies work in "
"Fabric, the `Modification policy`. Modification policies specify the "
"group of identities required to sign (approve) any configuration "
"_update_. It is the policy that defines how the policy is updated. Thus, "
"each channel configuration element includes a reference to a policy which"
" governs its modification."
msgstr ""

#: ../../source/policies/policies.md:140
msgid "## The Fabric policy domains"
msgstr ""

#: ../../source/policies/policies.md:142
msgid ""
"While Fabric policies are flexible and can be configured to meet the "
"needs of a network, the policy structure naturally leads to a division "
"between the domains governed by either the Ordering Service organizations"
" or the members of the consortium. In the following diagram you can see "
"how the default policies implement control over the Fabric policy domains"
" below."
msgstr ""

#: ../../source/policies/policies.md:148
msgid ""
"![policies.policies](./FabricPolicyHierarchy-4.png) *A more detailed look"
" at the policy domains governed by the Orderer organizations and "
"consortium organizations.*"
msgstr ""

#: ../../source/policies/policies.md:151
msgid ""
"A fully functional Fabric network can feature many organizations with "
"different responsibilities. The domains provide the ability to extend "
"different privileges and roles to different organizations by allowing the"
" founders of the ordering service the ability to establish the initial "
"rules and membership of the consortium. They also allow the organizations"
" that join the consortium to create private application channels, govern "
"their own business logic, and restrict access to the data that is put on "
"the network."
msgstr ""

#: ../../source/policies/policies.md:159
msgid ""
"The system channel configuration and a portion of each application "
"channel configuration provides the ordering organizations control over "
"which organizations are members of the consortium, how blocks are "
"delivered to channels, and the consensus mechanism used by the nodes of "
"the ordering service."
msgstr ""

#: ../../source/policies/policies.md:164
msgid ""
"The system channel configuration provides members of the consortium the "
"ability to create channels. Application channels and ACLs are the "
"mechanism that consortium organizations use to add or remove members from"
" a channel and restrict access to data and smart contracts on a channel."
msgstr ""

#: ../../source/policies/policies.md:169
msgid "## How do you write a policy in Fabric"
msgstr ""

#: ../../source/policies/policies.md:171
msgid ""
"If you want to change anything in Fabric, the policy associated with the "
"resource describes **who** needs to approve it, either with an explicit "
"sign off from individuals, or an implicit sign off by a group. In the "
"insurance domain, an explicit sign off could be a single member of the "
"homeowners insurance agents group. And an implicit sign off would be "
"analogous to requiring approval from a majority of the managerial members"
" of the homeowners insurance group. This is particularly useful because "
"the members of that group can change over time without requiring that the"
" policy be updated. In Hyperledger Fabric, explicit sign offs in policies"
" are expressed using the `Signature` syntax and implicit sign offs use "
"the `ImplicitMeta` syntax."
msgstr ""

#: ../../source/policies/policies.md:182
msgid "### Signature policies"
msgstr ""

#: ../../source/policies/policies.md:184
msgid ""
"`Signature` policies define specific types of users who must sign in "
"order for a policy to be satisfied such as `OR('Org1.peer', "
"'Org2.peer')`. These policies are considered the most versatile because "
"they allow for the construction of extremely specific rules like: “An "
"admin of org A and 2 other admins, or 5 of 6 organization admins”. The "
"syntax supports arbitrary combinations of `AND`, `OR` and `NOutOf`. For "
"example, a policy can be easily expressed by using `AND('Org1.member', "
"'Org2.member')` which means that a signature from at least one member in "
"Org1 AND one member in Org2 is required for the policy to be satisfied."
msgstr ""

#: ../../source/policies/policies.md:193
msgid "### ImplicitMeta policies"
msgstr ""

#: ../../source/policies/policies.md:195
msgid ""
"`ImplicitMeta` policies are only valid in the context of channel "
"configuration which is based on a tiered hierarchy of policies in a "
"configuration tree. ImplicitMeta policies aggregate the result of "
"policies deeper in the configuration tree that are ultimately defined by "
"Signature policies. They are `Implicit` because they are constructed "
"implicitly based on the current organizations in the channel "
"configuration, and they are `Meta` because their evaluation is not "
"against specific MSP principals, but rather against other sub-policies "
"below them in the configuration tree."
msgstr ""

#: ../../source/policies/policies.md:204
msgid ""
"The following diagram illustrates the tiered policy structure for an "
"application channel and shows how the `ImplicitMeta` channel "
"configuration admins policy, named `/Channel/Admins`, is resolved when "
"the sub-policies named `Admins` below it in the configuration hierarchy "
"are satisfied where each check mark represents that the conditions of the"
" sub-policy were satisfied."
msgstr ""

#: ../../source/policies/policies.md:210
msgid "![policies.policies](./FabricPolicyHierarchy-6.png)"
msgstr ""

#: ../../source/policies/policies.md:212
msgid ""
"As you can see in the diagram above, `ImplicitMeta` policies, Type = 3, "
"use a different syntax, `\"<ANY|ALL|MAJORITY> <SubPolicyName>\"`, for "
"example: ``` `MAJORITY sub policy: Admins` ``` The diagram shows a sub-"
"policy `Admins`, which refers to all the `Admins` policy below it in the "
"configuration tree. You can create your own sub-policies and name them "
"whatever you want and then define them in each of your organizations."
msgstr ""

#: ../../source/policies/policies.md:222
msgid ""
"As mentioned above, a key benefit of an `ImplicitMeta` policy such as "
"`MAJORITY Admins` is that when you add a new admin organization to the "
"channel, you do not have to update the channel policy. Therefore "
"`ImplicitMeta` policies are considered to be more flexible as the "
"consortium members change. The consortium on the orderer can change as "
"new members are added or an existing member leaves with the consortium "
"members agreeing to the changes, but no policy updates are required. "
"Recall that `ImplicitMeta` policies ultimately resolve the `Signature` "
"sub-policies underneath them in the configuration tree as the diagram "
"shows."
msgstr ""

#: ../../source/policies/policies.md:232
msgid ""
"You can also define an application level implicit policy to operate "
"across organizations, in a channel for example, and either require that "
"ANY of them are satisfied, that ALL are satisfied, or that a MAJORITY are"
" satisfied. This format lends itself to much better, more natural "
"defaults, so that each organization can decide what it means for a valid "
"endorsement."
msgstr ""

#: ../../source/policies/policies.md:238
msgid ""
"Further granularity and control can be achieved if you include "
"[`NodeOUs`](msp.html#organizational-units) in your organization "
"definition. Organization Units (OUs) are defined in the Fabric CA client "
"configuration file and can be associated with an identity when it is "
"created. In Fabric, `NodeOUs` provide a way to classify identities in a "
"digital certificate hierarchy. For instance, an organization having "
"specific `NodeOUs` enabled could require that a 'peer' sign for it to be "
"a valid endorsement, whereas an organization without any might simply "
"require that any member can sign."
msgstr ""

#: ../../source/policies/policies.md:247
msgid "## An example: channel configuration policy"
msgstr ""

#: ../../source/policies/policies.md:249
msgid ""
"Understanding policies begins with examining the `configtx.yaml` where "
"the channel policies are defined. We can use the `configtx.yaml` file in "
"the Fabric test network to see examples of both policy syntax types. We "
"are going to examine the configtx.yaml file used by the [fabric-samples"
"/test-network](https://github.com/hyperledger/fabric-samples/blob/master"
"/test-network/configtx/configtx.yaml) sample."
msgstr ""

#: ../../source/policies/policies.md:254
msgid ""
"The first section of the file defines the organizations of the network. "
"Inside each organization definition are the default policies for that "
"organization, `Readers`, `Writers`, `Admins`, and `Endorsement`, although"
" you can name your policies anything you want. Each policy has a `Type` "
"which describes how the policy is expressed (`Signature` or "
"`ImplicitMeta`) and a `Rule`."
msgstr ""

#: ../../source/policies/policies.md:260
msgid ""
"The test network example below shows the Org1 organization definition in "
"the system channel, where the policy `Type` is `Signature` and the "
"endorsement policy rule is defined as `\"OR('Org1MSP.peer')\"`. This "
"policy specifies that a peer that is a member of `Org1MSP` is required to"
" sign. It is these signature policies that become the sub-policies that "
"the ImplicitMeta policies point to."
msgstr ""

#: ../../source/policies/policies.md:269 ../../source/policies/policies.md:316
msgid "<details>"
msgstr ""

#: ../../source/policies/policies.md:267 ../../source/policies/policies.md:315
msgid "<summary>"
msgstr ""

#: ../../source/policies/policies.md:268
msgid ""
"**Click here to see an example of an organization defined with signature "
"policies**"
msgstr ""

#: ../../source/policies/policies.md:269 ../../source/policies/policies.md:317
msgid "</summary>"
msgstr ""

#: ../../source/policies/policies.md:296 ../../source/policies/policies.md:319
#: ../../source/policies/policies.md:374 ../../source/policies/policies.md:407
msgid "```"
msgstr ""

#: ../../source/policies/policies.md:296
msgid "&Org1"
msgstr ""

#: ../../source/policies/policies.md:273
msgid ""
"# DefaultOrg defines the organization which is used in the sampleconfig #"
" of the fabric.git development environment Name: Org1MSP"
msgstr ""

#: ../../source/policies/policies.md:277
msgid "# ID to load the MSP definition as ID: Org1MSP"
msgstr ""

#: ../../source/policies/policies.md:280
msgid "MSPDir: crypto-config/peerOrganizations/org1.example.com/msp"
msgstr ""

#: ../../source/policies/policies.md:282
msgid ""
"# Policies defines the set of policies at this level of the config tree #"
" For organization policies, their canonical path is usually #   "
"/Channel/<Application|Orderer>/<OrgName>/<PolicyName> Policies:"
msgstr ""

#: ../../source/policies/policies.md:287 ../../source/policies/policies.md:338
#: ../../source/policies/policies.md:393
msgid "Readers:"
msgstr ""

#: ../../source/policies/policies.md:287
msgid ""
"Type: Signature Rule: \"OR('Org1MSP.admin', 'Org1MSP.peer', "
"'Org1MSP.client')\""
msgstr ""

#: ../../source/policies/policies.md:290 ../../source/policies/policies.md:341
#: ../../source/policies/policies.md:396
msgid "Writers:"
msgstr ""

#: ../../source/policies/policies.md:290
msgid "Type: Signature Rule: \"OR('Org1MSP.admin', 'Org1MSP.client')\""
msgstr ""

#: ../../source/policies/policies.md:293 ../../source/policies/policies.md:344
#: ../../source/policies/policies.md:399
msgid "Admins:"
msgstr ""

#: ../../source/policies/policies.md:293
msgid "Type: Signature Rule: \"OR('Org1MSP.admin')\""
msgstr ""

#: ../../source/policies/policies.md:296 ../../source/policies/policies.md:350
#: ../../source/policies/policies.md:405
msgid "Endorsement:"
msgstr ""

#: ../../source/policies/policies.md:296
msgid "Type: Signature Rule: \"OR('Org1MSP.peer')\""
msgstr ""

#: ../../source/policies/policies.md:298 ../../source/policies/policies.md:352
msgid "``` </details>"
msgstr ""

#: ../../source/policies/policies.md:301
msgid ""
"The next example shows the `ImplicitMeta` policy type used in the "
"`Application` section of the `configtx.yaml`. These set of policies lie "
"on the `/Channel/Application/` path. If you use the default set of Fabric"
" ACLs, these policies define the behavior of many important features of "
"application channels, such as who can query the channel ledger, invoke a "
"chaincode, or update a channel config. These policies point to the sub-"
"policies defined for each organization. The Org1 defined in the section "
"above contains `Reader`, `Writer`, and `Admin` sub-policies that are "
"evaluated by the `Reader`, `Writer`, and `Admin` `ImplicitMeta` policies "
"in the `Application` section. Because the test network is built with the "
"default policies, you can use the example Org1 to query the channel "
"ledger, invoke a chaincode, and approve channel updates for any test "
"network channel that you create."
msgstr ""

#: ../../source/policies/policies.md:316
msgid "**Click here to see an example of ImplicitMeta policies**"
msgstr ""

#: ../../source/policies/policies.md:320 ../../source/policies/policies.md:375
msgid ""
"# #   SECTION: Application # #   - This section defines the values to "
"encode into a config transaction or #   genesis block for application "
"related parameters # "
"################################################################################"
" Application: &ApplicationDefaults"
msgstr ""

#: ../../source/policies/policies.md:329 ../../source/policies/policies.md:384
msgid ""
"# Organizations is the list of orgs which are defined as participants on "
"# the application side of the network Organizations:"
msgstr ""

#: ../../source/policies/policies.md:333 ../../source/policies/policies.md:388
msgid ""
"# Policies defines the set of policies at this level of the config tree #"
" For Application policies, their canonical path is #   "
"/Channel/Application/<PolicyName> Policies:"
msgstr ""

#: ../../source/policies/policies.md:338 ../../source/policies/policies.md:393
msgid "Type: ImplicitMeta Rule: \"ANY Readers\""
msgstr ""

#: ../../source/policies/policies.md:341 ../../source/policies/policies.md:396
msgid "Type: ImplicitMeta Rule: \"ANY Writers\""
msgstr ""

#: ../../source/policies/policies.md:344 ../../source/policies/policies.md:399
msgid "Type: ImplicitMeta Rule: \"MAJORITY Admins\""
msgstr ""

#: ../../source/policies/policies.md:347 ../../source/policies/policies.md:402
msgid "LifecycleEndorsement:"
msgstr ""

#: ../../source/policies/policies.md:347 ../../source/policies/policies.md:350
#: ../../source/policies/policies.md:402 ../../source/policies/policies.md:405
msgid "Type: ImplicitMeta Rule: \"MAJORITY Endorsement\""
msgstr ""

#: ../../source/policies/policies.md:355
msgid "## Fabric chaincode lifecycle"
msgstr ""

#: ../../source/policies/policies.md:357
msgid ""
"In the Fabric 2.0 release, a new chaincode lifecycle process was "
"introduced, whereby a more democratic process is used to govern chaincode"
" on the network. The new process allows multiple organizations to vote on"
" how a chaincode will be operated before it can be used on a channel. "
"This is significant because it is the combination of this new lifecycle "
"process and the policies that are specified during that process that "
"dictate the security across the network. More details on the flow are "
"available in the [Fabric chaincode "
"lifecycle](../chaincode_lifecycle.html) concept topic, but for purposes "
"of this topic you should understand how policies are used in this flow. "
"The new flow includes two steps where policies are specified: when "
"chaincode is **approved** by organization members, and when it is "
"**committed** to the channel."
msgstr ""

#: ../../source/policies/policies.md:369
msgid ""
"The `Application` section of  the `configtx.yaml` file includes the "
"default chaincode lifecycle endorsement policy. In a production "
"environment you would customize this definition for your own use case."
msgstr ""

#: ../../source/policies/policies.md:409
msgid ""
"The `LifecycleEndorsement` policy governs who needs to _approve a "
"chaincode"
msgstr ""

#: ../../source/policies/policies.md:410
msgid ""
"definition_. - The `Endorsement` policy is the _default endorsement "
"policy for a chaincode_. More on this below."
msgstr ""

#: ../../source/policies/policies.md:414
msgid "## Chaincode endorsement policies"
msgstr ""

#: ../../source/policies/policies.md:416
msgid ""
"The endorsement policy is specified for a **chaincode** when it is "
"approved and committed to the channel using the Fabric chaincode "
"lifecycle (that is, one endorsement policy covers all of the state "
"associated with a chaincode). The endorsement policy can be specified "
"either by reference to an endorsement policy defined in the channel "
"configuration or by explicitly specifying a Signature policy."
msgstr ""

#: ../../source/policies/policies.md:422
msgid ""
"If an endorsement policy is not explicitly specified during the approval "
"step, the default `Endorsement` policy `\"MAJORITY Endorsement\"` is used"
" which means that a majority of the peers belonging to the different "
"channel members (organizations) need to execute and validate a "
"transaction against the chaincode in order for the transaction to be "
"considered valid.  This default policy allows organizations that join the"
" channel to become automatically added to the chaincode endorsement "
"policy. If you don't want to use the default endorsement policy, use the "
"Signature policy format to specify a more complex endorsement policy "
"(such as requiring that a chaincode be endorsed by one organization, and "
"then one of the other organizations on the channel)."
msgstr ""

#: ../../source/policies/policies.md:433
msgid ""
"Signature policies also allow you to include `principals` which are "
"simply a way of matching an identity to a role. Principals are just like "
"user IDs or group IDs, but they are more versatile because they can "
"include a wide range of properties of an actor’s identity, such as the "
"actor’s organization, organizational unit, role or even the actor’s "
"specific identity. When we talk about principals, they are the properties"
" which determine their permissions. Principals are described as "
"'MSP.ROLE', where `MSP` represents the required MSP ID (the "
"organization),  and `ROLE` represents one of the four accepted roles: "
"Member, Admin, Client, and Peer. A role is associated to an identity when"
" a user enrolls with a CA. You can customize the list of roles available "
"on your Fabric CA."
msgstr ""

#: ../../source/policies/policies.md:445
msgid ""
"Some examples of valid principals are: * 'Org0.Admin': an administrator "
"of the Org0 MSP * 'Org1.Member': a member of the Org1 MSP * "
"'Org1.Client': a client of the Org1 MSP * 'Org1.Peer': a peer of the Org1"
" MSP * 'OrdererOrg.Orderer': an orderer in the OrdererOrg MSP"
msgstr ""

#: ../../source/policies/policies.md:452
msgid ""
"There are cases where it may be necessary for a particular state (a "
"particular key-value pair, in other words) to have a different "
"endorsement policy. This **state-based endorsement** allows the default "
"chaincode-level endorsement policies to be overridden by a different "
"policy for the specified keys."
msgstr ""

#: ../../source/policies/policies.md:458
msgid ""
"For a deeper dive on how to write an endorsement policy refer to the "
"topic on [Endorsement policies](../endorsement-policies.html) in the "
"Operations Guide."
msgstr ""

#: ../../source/policies/policies.md:461
msgid ""
"**Note:**  Policies work differently depending on which version of Fabric"
" you are"
msgstr ""

#: ../../source/policies/policies.md:462
msgid "using:"
msgstr ""

#: ../../source/policies/policies.md:463
msgid ""
"In Fabric releases prior to 2.0, chaincode endorsement policies can be "
"updated during chaincode instantiation or by using the chaincode "
"lifecycle commands. If not specified at instantiation time, the "
"endorsement policy defaults to “any member of the organizations in the "
"channel”. For example, a channel with “Org1” and “Org2” would have a "
"default endorsement policy of “OR(‘Org1.member’, ‘Org2.member’)”."
msgstr ""

#: ../../source/policies/policies.md:469
msgid ""
"Starting with Fabric 2.0, Fabric introduced a new chaincode lifecycle "
"process that allows multiple organizations to agree on how a chaincode "
"will be operated before it can be used on a channel.  The new process "
"requires that organizations agree to the parameters that define a "
"chaincode, such as name, version, and the chaincode endorsement policy."
msgstr ""

#: ../../source/policies/policies.md:475
msgid "## Overriding policy definitions"
msgstr ""

#: ../../source/policies/policies.md:477
msgid ""
"Hyperledger Fabric includes default policies which are useful for getting"
" started, developing, and testing your blockchain, but they are meant to "
"be customized in a production environment. You should be aware of the "
"default policies in the `configtx.yaml` file. Channel configuration "
"policies can be extended with arbitrary verbs, beyond the default "
"`Readers, Writers, Admins` in `configtx.yaml`. The orderer system and "
"application channels are overridden by issuing a config update when you "
"override the default policies by editing the `configtx.yaml` for the "
"orderer system channel or the `configtx.yaml` for a specific channel."
msgstr ""

#: ../../source/policies/policies.md:487
msgid ""
"See the topic on [Updating a channel "
"configuration](../config_update.html#updating-a-channel-configuration) "
"for more information."
msgstr ""

#: ../../source/policies/policies.md:491
msgid ""
"<!--- Licensed under Creative Commons Attribution 4.0 International "
"License https://creativecommons.org/licenses/by/4.0/) -->"
msgstr ""

