# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017, hyperledger
# This file is distributed under the same license as the
# hyperledger-fabricdocs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: hyperledger-fabricdocs master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-07-19 19:02+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../source/developapps/analysis.md:1
msgid "# Analysis"
msgstr ""

#: ../../source/developapps/analysis.md:3
#: ../../source/developapps/architecture.md:3
#: ../../source/developapps/scenario.md:3
msgid ""
"**Audience**: Architects, Application and smart contract developers, "
"Business professionals"
msgstr ""

#: ../../source/developapps/analysis.md:6
msgid ""
"Let's analyze commercial paper in a little more detail. PaperNet "
"participants such as MagnetoCorp and DigiBank use commercial paper "
"transactions to achieve their business objectives -- let's examine the "
"structure of a commercial paper and the transactions that affect it over "
"time. We will also consider which organizations in PaperNet need to sign "
"off on a transaction based on the trust relationships among the "
"organizations in the network. Later we'll focus on how money flows "
"between buyers and sellers; for now, let's focus on the first paper "
"issued by MagnetoCorp."
msgstr ""

#: ../../source/developapps/analysis.md:15
msgid "## Commercial paper lifecycle"
msgstr ""

#: ../../source/developapps/analysis.md:17
msgid ""
"A paper 00001 is issued by MagnetoCorp on May 31. Spend a few moments "
"looking at the first **state** of this paper, with its different "
"properties and values:"
msgstr ""

#: ../../source/developapps/analysis.md:20
msgid ""
"``` Issuer = MagnetoCorp Paper = 00001 Owner = MagnetoCorp Issue date = "
"31 May 2020 Maturity = 30 November 2020 Face value = 5M USD Current state"
" = issued ```"
msgstr ""

#: ../../source/developapps/analysis.md:30
msgid ""
"This paper state is a result of the **issue** transaction and it brings "
"MagnetoCorp's first commercial paper into existence! Notice how this "
"paper has a 5M USD face value for redemption later in the year. See how "
"the `Issuer` and `Owner` are the same when paper 00001 is issued. Notice "
"that this paper could be uniquely identified as `MagnetoCorp00001` -- a "
"composition of the `Issuer` and `Paper` properties. Finally, see how the "
"property `Current state = issued` quickly identifies the stage of "
"MagnetoCorp paper 00001 in its lifecycle."
msgstr ""

#: ../../source/developapps/analysis.md:38
msgid ""
"Shortly after issuance, the paper is bought by DigiBank. Spend a few "
"moments looking at how the same commercial paper has changed as a result "
"of this **buy** transaction:"
msgstr ""

#: ../../source/developapps/analysis.md:42
msgid ""
"``` Issuer = MagnetoCorp Paper = 00001 Owner = DigiBank Issue date = 31 "
"May 2020 Maturity date = 30 November 2020 Face value = 5M USD Current "
"state = trading ```"
msgstr ""

#: ../../source/developapps/analysis.md:52
msgid ""
"The most significant change is that of `Owner` -- see how the paper "
"initially owned by `MagnetoCorp` is now owned by `DigiBank`.  We could "
"imagine how the paper might be subsequently sold to BrokerHouse or "
"HedgeMatic, and the corresponding change to `Owner`. Note how `Current "
"state` allow us to easily identify that the paper is now `trading`."
msgstr ""

#: ../../source/developapps/analysis.md:58
msgid ""
"After 6 months, if DigiBank still holds the commercial paper, it can "
"redeem it with MagnetoCorp:"
msgstr ""

#: ../../source/developapps/analysis.md:61
msgid ""
"``` Issuer = MagnetoCorp Paper = 00001 Owner = MagnetoCorp Issue date = "
"31 May 2020 Maturity date = 30 November 2020 Face value = 5M USD Current "
"state = redeemed ```"
msgstr ""

#: ../../source/developapps/analysis.md:71
msgid ""
"This final **redeem** transaction has ended the commercial paper's "
"lifecycle -- it can be considered closed. It is often mandatory to keep a"
" record of redeemed commercial papers, and the `redeemed` state allows us"
" to quickly identify these. The value of `Owner` of a paper can be used "
"to perform access control on the **redeem** transaction, by comparing the"
" `Owner` against the identity of the transaction creator. Fabric supports"
" this through the [`getCreator()` chaincode "
"API](https://github.com/hyperledger/fabric-chaincode-node/blob/master"
"/fabric-shim/lib/stub.js#L293). If Go is used as a chaincode language, "
"the [client identity chaincode library](https://github.com/hyperledger"
"/fabric-chaincode-go/blob/master/pkg/cid/README.md) can be used to "
"retrieve additional attributes of the transaction creator."
msgstr ""

#: ../../source/developapps/analysis.md:81
msgid "## Transactions"
msgstr ""

#: ../../source/developapps/analysis.md:83
msgid ""
"We've seen that paper 00001's lifecycle is relatively straightforward -- "
"it moves between `issued`, `trading` and `redeemed` as a result of an "
"**issue**, **buy**, or **redeem** transaction."
msgstr ""

#: ../../source/developapps/analysis.md:87
msgid ""
"These three transactions are initiated by MagnetoCorp and DigiBank "
"(twice), and drive the state changes of paper 00001. Let's have a look at"
" the transactions that affect this paper in a little more detail:"
msgstr ""

#: ../../source/developapps/analysis.md:91
msgid "### Issue"
msgstr ""

#: ../../source/developapps/analysis.md:93
msgid "Examine the first transaction initiated by MagnetoCorp:"
msgstr ""

#: ../../source/developapps/analysis.md:95
#: ../../source/developapps/application.md:273
#: ../../source/developapps/smartcontract.md:187
#: ../../source/developapps/smartcontract.md:347
msgid ""
"``` Txn = issue Issuer = MagnetoCorp Paper = 00001 Issue time = 31 May "
"2020 09:00:00 EST Maturity date = 30 November 2020 Face value = 5M USD "
"```"
msgstr ""

#: ../../source/developapps/analysis.md:104
msgid ""
"See how the **issue** transaction has a structure with properties and "
"values. This transaction structure is different to, but closely matches, "
"the structure of paper 00001. That's because they are different things --"
" paper 00001 reflects a state of PaperNet that is a result of the "
"**issue** transaction. It's the logic behind the **issue** transaction "
"(which we cannot see) that takes these properties and creates this paper."
" Because the transaction **creates** the paper, it means there's a very "
"close relationship between these structures."
msgstr ""

#: ../../source/developapps/analysis.md:112
msgid ""
"The only organization that is involved in the **issue** transaction is "
"MagnetoCorp. Naturally, MagnetoCorp needs to sign off on the transaction."
" In general, the issuer of a paper is required to sign off on a "
"transaction that issues a new paper."
msgstr ""

#: ../../source/developapps/analysis.md:116
msgid "### Buy"
msgstr ""

#: ../../source/developapps/analysis.md:118
msgid ""
"Next, examine the **buy** transaction which transfers ownership of paper "
"00001 from MagnetoCorp to DigiBank:"
msgstr ""

#: ../../source/developapps/analysis.md:121
#: ../../source/developapps/smartcontract.md:273
msgid ""
"``` Txn = buy Issuer = MagnetoCorp Paper = 00001 Current owner = "
"MagnetoCorp New owner = DigiBank Purchase time = 31 May 2020 10:00:00 EST"
" Price = 4.94M USD ```"
msgstr ""

#: ../../source/developapps/analysis.md:131
msgid ""
"See how the **buy** transaction has fewer properties that end up in this "
"paper. That's because this transaction only **modifies** this paper. It's"
" only `New owner = DigiBank` that changes as a result of this "
"transaction; everything else is the same. That's OK -- the most important"
" thing about the **buy** transaction is the change of ownership, and "
"indeed in this transaction, there's an acknowledgement of the current "
"owner of the paper, MagnetoCorp."
msgstr ""

#: ../../source/developapps/analysis.md:138
msgid ""
"You might ask why the `Purchase time` and `Price` properties are not "
"captured in paper 00001? This comes back to the difference between the "
"transaction and the paper. The 4.94 M USD price tag is actually a "
"property of the transaction, rather than a property of this paper. Spend "
"a little time thinking about this difference; it is not as obvious as it "
"seems. We're going to see later that the ledger will record both pieces "
"of information -- the history of all transactions that affect this paper,"
" as well its latest state. Being clear on this separation of information "
"is really important."
msgstr ""

#: ../../source/developapps/analysis.md:147
msgid ""
"It's also worth remembering that paper 00001 may be bought and sold many "
"times. Although we're skipping ahead a little in our scenario, let's "
"examine what transactions we **might** see if paper 00001 changes "
"ownership."
msgstr ""

#: ../../source/developapps/analysis.md:151
msgid "If we have a purchase by BigFund:"
msgstr ""

#: ../../source/developapps/analysis.md:153
msgid ""
"``` Txn = buy Issuer = MagnetoCorp Paper = 00001 Current owner = DigiBank"
" New owner = BigFund Purchase time = 2 June 2020 12:20:00 EST Price = "
"4.93M USD ``` Followed by a subsequent purchase by HedgeMatic: ``` Txn = "
"buy Issuer = MagnetoCorp Paper = 00001 Current owner = BigFund New owner "
"= HedgeMatic Purchase time = 3 June 2020 15:59:00 EST Price = 4.90M USD "
"```"
msgstr ""

#: ../../source/developapps/analysis.md:173
msgid ""
"See how the paper owners changes, and how in our example, the price "
"changes. Can you think of a reason why the price of MagnetoCorp "
"commercial paper might be falling?"
msgstr ""

#: ../../source/developapps/analysis.md:177
msgid ""
"Intuitively, a **buy** transaction demands that both the selling as well "
"as the buying organization need to sign off on such a transaction such "
"that there is proof of the mutual agreement among the two parties that "
"are part of the deal."
msgstr ""

#: ../../source/developapps/analysis.md:181
msgid "### Redeem"
msgstr ""

#: ../../source/developapps/analysis.md:183
msgid ""
"The **redeem** transaction for paper 00001 represents the end of its "
"lifecycle. In our relatively simple example, HedgeMatic initiates the "
"transaction which transfers the commercial paper back to MagnetoCorp:"
msgstr ""

#: ../../source/developapps/analysis.md:187
msgid ""
"``` Txn = redeem Issuer = MagnetoCorp Paper = 00001 Current owner = "
"HedgeMatic Redeem time = 30 Nov 2020 12:00:00 EST ```"
msgstr ""

#: ../../source/developapps/analysis.md:195
msgid ""
"Again, notice how the **redeem** transaction has very few properties; all"
" of the changes to paper 00001 can be calculated data by the redeem "
"transaction logic: the `Issuer` will become the new owner, and the "
"`Current state` will change to `redeemed`. The `Current owner` property "
"is specified in our example, so that it can be checked against the "
"current holder of the paper."
msgstr ""

#: ../../source/developapps/analysis.md:201
msgid ""
"From a trust perspective, the same reasoning of the **buy** transaction "
"also applies to the **redeem** instruction: both organizations involved "
"in the transaction are required to sign off on it."
msgstr ""

#: ../../source/developapps/analysis.md:205
msgid "## The Ledger"
msgstr ""

#: ../../source/developapps/analysis.md:207
msgid ""
"In this topic, we've seen how transactions and the resultant paper states"
" are the two most important concepts in PaperNet. Indeed, we'll see these"
" two fundamental elements in any Hyperledger Fabric distributed "
"[ledger](../ledger/ledger.html) -- a world state, that contains the "
"current value of all objects, and a blockchain that records the history "
"of all transactions that resulted in the current world state."
msgstr ""

#: ../../source/developapps/analysis.md:214
msgid ""
"The required sign-offs on transactions are enforced through rules, which "
"are evaluated before appending a transaction to the ledger. Only if the "
"required signatures are present, Fabric will accept a transaction as "
"valid."
msgstr ""

#: ../../source/developapps/analysis.md:218
msgid ""
"You're now in a great place translate these ideas into a smart contract. "
"Don't worry if your programming is a little rusty, we'll provide tips and"
" pointers to understand the program code. Mastering the commercial paper "
"smart contract is the first big step towards designing your own "
"application. Or, if you're a business analyst who's comfortable with a "
"little programming, don't be afraid to keep dig a little deeper!"
msgstr ""

#: ../../source/developapps/analysis.md:225
#: ../../source/developapps/application.md:358
#: ../../source/developapps/architecture.md:186
#: ../../source/developapps/chaincodenamespace.md:296
#: ../../source/developapps/connectionoptions.md:249
#: ../../source/developapps/connectionprofile.md:498
#: ../../source/developapps/contractname.md:153
#: ../../source/developapps/endorsementpolicies.md:22
#: ../../source/developapps/gateway.md:188
#: ../../source/developapps/scenario.md:92
#: ../../source/developapps/smartcontract.md:719
#: ../../source/developapps/transactioncontext.md:279
#: ../../source/developapps/wallet.md:230
msgid ""
"<!--- Licensed under Creative Commons Attribution 4.0 International "
"License https://creativecommons.org/licenses/by/4.0/ -->"
msgstr ""

#: ../../source/developapps/apis.md:1
msgid "# APIs"
msgstr ""

#: ../../source/developapps/apis.md:3
msgid "This topic deferred to Fabric 2.0"
msgstr ""

#: ../../source/developapps/application.md:1
msgid "# Application"
msgstr ""

#: ../../source/developapps/application.md:3
#: ../../source/developapps/endorsementpolicies.md:3
#: ../../source/developapps/smartcontract.md:3
#: ../../source/developapps/transactionhandler.md:3
msgid "**Audience**: Architects, Application and smart contract developers"
msgstr ""

#: ../../source/developapps/application.md:5
msgid ""
"An application can interact with a blockchain network by submitting "
"transactions to a ledger or querying ledger content. This topic covers "
"the mechanics of how an application does this; in our scenario, "
"organizations access PaperNet using applications which invoke **issue**, "
"**buy** and **redeem** transactions defined in a commercial paper smart "
"contract. Even though MagnetoCorp's application to issue a commercial "
"paper is basic, it covers all the major points of understanding."
msgstr ""

#: ../../source/developapps/application.md:13
#: ../../source/developapps/chaincodenamespace.md:14
#: ../../source/developapps/connectionoptions.md:10
#: ../../source/developapps/connectionprofile.md:13
#: ../../source/developapps/gateway.md:9 ../../source/developapps/wallet.md:10
msgid "In this topic, we're going to cover:"
msgstr ""

#: ../../source/developapps/application.md:15
msgid "[The application flow to invoke a smart contract](#basic-flow)"
msgstr ""

#: ../../source/developapps/application.md:16
msgid "[How an application uses a wallet and identity](#wallet)"
msgstr ""

#: ../../source/developapps/application.md:17
msgid "[How an application connects using a gateway](#gateway)"
msgstr ""

#: ../../source/developapps/application.md:18
msgid "[How to access a particular network](#network-channel)"
msgstr ""

#: ../../source/developapps/application.md:19
msgid "[How to construct a transaction request](#construct-request)"
msgstr ""

#: ../../source/developapps/application.md:20
msgid "[How to submit a transaction](#submit-transaction)"
msgstr ""

#: ../../source/developapps/application.md:21
msgid "[How to process a transaction response](#process-response)"
msgstr ""

#: ../../source/developapps/application.md:23
msgid ""
"To help your understanding, we'll make reference to the commercial paper "
"sample application provided with Hyperledger Fabric. You can [download "
"it](../install.html) and [run it "
"locally](../tutorial/commercial_paper.html). It is written in both "
"JavaScript and Java, but the logic is quite language independent, so "
"you'll easily be able to see what's going on! (The sample will become "
"available for  Go as well.)"
msgstr ""

#: ../../source/developapps/application.md:29
msgid "## Basic Flow"
msgstr ""

#: ../../source/developapps/application.md:31
msgid ""
"An application interacts with a blockchain network using the Fabric SDK. "
"Here's a simplified diagram of how an application invokes a commercial "
"paper smart contract:"
msgstr ""

#: ../../source/developapps/application.md:35
msgid ""
"![develop.application](./develop.diagram.3.png) *A PaperNet application "
"invokes the commercial paper smart contract to submit an issue "
"transaction request.*"
msgstr ""

#: ../../source/developapps/application.md:38
msgid "An application has to follow six basic steps to submit a transaction:"
msgstr ""

#: ../../source/developapps/application.md:40
msgid "Select an identity from a wallet"
msgstr ""

#: ../../source/developapps/application.md:41
msgid "Connect to a gateway"
msgstr ""

#: ../../source/developapps/application.md:42
msgid "Access the desired network"
msgstr ""

#: ../../source/developapps/application.md:43
msgid "Construct a transaction request for a smart contract"
msgstr ""

#: ../../source/developapps/application.md:44
msgid "Submit the transaction to the network"
msgstr ""

#: ../../source/developapps/application.md:45
msgid "Process the response"
msgstr ""

#: ../../source/developapps/application.md:47
msgid ""
"You're going to see how a typical application performs these six steps "
"using the Fabric SDK. You'll find the application code in the `issue.js` "
"file. [View it](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-paper/organization/magnetocorp/application/issue.js) in your "
"browser, or open it in your favourite editor if you've downloaded it. "
"Spend a few moments looking at the overall structure of the application; "
"even with comments and spacing, it's only 100 lines of code!"
msgstr ""

#: ../../source/developapps/application.md:54
msgid "## Wallet"
msgstr ""

#: ../../source/developapps/application.md:56
msgid ""
"Towards the top of `issue.js`, you'll see two Fabric classes are brought "
"into scope:"
msgstr ""

#: ../../source/developapps/application.md:59
msgid "```JavaScript const { Wallets, Gateway } = require('fabric-network'); ```"
msgstr ""

#: ../../source/developapps/application.md:63
msgid ""
"You can read about the `fabric-network` classes in the [node SDK "
"documentation](https://hyperledger.github.io/fabric-sdk-node/master"
"/module-fabric-network.html), but for now, let's see how they are used to"
" connect MagnetoCorp's application to PaperNet. The application uses the "
"Fabric **Wallet** class as follows:"
msgstr ""

#: ../../source/developapps/application.md:68
msgid ""
"```JavaScript const wallet = await "
"Wallets.newFileSystemWallet('../identity/user/isabella/wallet'); ```"
msgstr ""

#: ../../source/developapps/application.md:72
msgid ""
"See how `wallet` locates a [wallet](./wallet.html) in the local "
"filesystem. The identity retrieved from the wallet is clearly for a user "
"called Isabella, who is using the `issue` application. The wallet holds a"
" set of identities -- X.509 digital certificates -- which can be used to "
"access PaperNet or any other Fabric network. If you run the tutorial, and"
" look in this directory, you'll see the identity credentials for "
"Isabella."
msgstr ""

#: ../../source/developapps/application.md:79
msgid ""
"Think of a [wallet](./wallet.html) holding the digital equivalents of "
"your government ID, driving license or ATM card. The X.509 digital "
"certificates within it will associate the holder with a organization, "
"thereby entitling them to rights in a network channel. For example, "
"`Isabella` might be an administrator in MagnetoCorp, and this could give "
"her more privileges than a different user -- `Balaji` from DigiBank.  "
"Moreover, a smart contract can retrieve this identity during smart "
"contract processing using the [transaction "
"context](./transactioncontext.html)."
msgstr ""

#: ../../source/developapps/application.md:88
msgid ""
"Note also that wallets don't hold any form of cash or tokens -- they hold"
" identities."
msgstr ""

#: ../../source/developapps/application.md:91
msgid "## Gateway"
msgstr ""

#: ../../source/developapps/application.md:93
msgid ""
"The second key class is a Fabric **Gateway**. Most importantly, a "
"[gateway](./gateway.html) identifies one or more peers that provide "
"access to a network -- in our case, PaperNet. See how `issue.js` connects"
" to its gateway:"
msgstr ""

#: ../../source/developapps/application.md:97
msgid ""
"```JavaScript await gateway.connect(connectionProfile, "
"connectionOptions); ```"
msgstr ""

#: ../../source/developapps/application.md:101
msgid "`gateway.connect()` has two important parameters:"
msgstr ""

#: ../../source/developapps/application.md:103
msgid ""
"**connectionProfile**: the file system location of a [connection "
"profile](./connectionprofile.html) that identifies a set of peers as a "
"gateway to PaperNet"
msgstr ""

#: ../../source/developapps/application.md:107
msgid ""
"**connectionOptions**: a set of options used to control how `issue.js` "
"interacts with PaperNet"
msgstr ""

#: ../../source/developapps/application.md:111
msgid ""
"See how the client application uses a gateway to insulate itself from the"
" network topology, which might change. The gateway takes care of sending "
"the transaction proposal to the right peer nodes in the network using the"
" [connection profile](./connectionprofile.html) and [connection "
"options](./connectionoptions.html)."
msgstr ""

#: ../../source/developapps/application.md:117
msgid ""
"Spend a few moments examining the connection "
"[profile](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-"
"paper/organization/magnetocorp/gateway/networkConnection.yaml) "
"`./gateway/connectionProfile.yaml`. It uses "
"[YAML](http://yaml.org/spec/1.2/spec.html#Preview), making it easy to "
"read."
msgstr ""

#: ../../source/developapps/application.md:122
msgid "It was loaded and converted into a JSON object:"
msgstr ""

#: ../../source/developapps/application.md:124
msgid ""
"```JavaScript let connectionProfile = "
"yaml.safeLoad(file.readFileSync('./gateway/connectionProfile.yaml', "
"'utf8')); ```"
msgstr ""

#: ../../source/developapps/application.md:128
msgid ""
"Right now, we're only interested in the `channels:` and `peers:` sections"
" of the profile: (We've modified the details slightly to better explain "
"what's happening.)"
msgstr ""

#: ../../source/developapps/application.md:132
msgid "```YAML channels:"
msgstr ""

#: ../../source/developapps/application.md:142
msgid "papernet:"
msgstr ""

#: ../../source/developapps/application.md:142
#: ../../source/developapps/application.md:157
#: ../../source/developapps/wallet.md:156
msgid "peers:"
msgstr ""

#: ../../source/developapps/application.md:138
#: ../../source/developapps/application.md:151
msgid "peer1.magnetocorp.com:"
msgstr ""

#: ../../source/developapps/application.md:137
#: ../../source/developapps/application.md:141
msgid "endorsingPeer: true eventSource: true"
msgstr ""

#: ../../source/developapps/application.md:142
#: ../../source/developapps/application.md:157
msgid "peer2.digibank.com:"
msgstr ""

#: ../../source/developapps/application.md:146
msgid "url: grpcs://localhost:7051 grpcOptions:"
msgstr ""

#: ../../source/developapps/application.md:148
msgid "ssl-target-name-override: peer1.magnetocorp.com request-timeout: 120"
msgstr ""

#: ../../source/developapps/application.md:151
#: ../../source/developapps/application.md:157
msgid "tlsCACerts:"
msgstr ""

#: ../../source/developapps/application.md:151
msgid "path: certificates/magnetocorp/magnetocorp.com-cert.pem"
msgstr ""

#: ../../source/developapps/application.md:154
msgid "url: grpcs://localhost:8051 grpcOptions:"
msgstr ""

#: ../../source/developapps/application.md:156
msgid "ssl-target-name-override: peer1.digibank.com"
msgstr ""

#: ../../source/developapps/application.md:158
msgid "path: certificates/digibank/digibank.com-cert.pem"
msgstr ""

#: ../../source/developapps/application.md:159
#: ../../source/developapps/contractname.md:67
#: ../../source/developapps/gateway.md:91
#: ../../source/developapps/wallet.md:158
#: ../../source/developapps/wallet.md:168
msgid "```"
msgstr ""

#: ../../source/developapps/application.md:161
msgid ""
"See how `channel:` identifies the `PaperNet:` network channel, and two of"
" its peers. MagnetoCorp has `peer1.magenetocorp.com` and DigiBank has "
"`peer2.digibank.com`, and both have the role of endorsing peers. Link to "
"these peers via the `peers:` key, which contains details about how to "
"connect to them, including their respective network addresses."
msgstr ""

#: ../../source/developapps/application.md:167
msgid ""
"The connection profile contains a lot of information -- not just peers --"
" but network channels, network orderers, organizations, and CAs, so don't"
" worry if you don't understand all of it!"
msgstr ""

#: ../../source/developapps/application.md:171
msgid "Let's now turn our attention to the `connectionOptions` object:"
msgstr ""

#: ../../source/developapps/application.md:173
#: ../../source/developapps/application.md:188
msgid "```JavaScript let connectionOptions = {"
msgstr ""

#: ../../source/developapps/application.md:175
msgid ""
"identity: userName, wallet: wallet, discovery: { enabled:true, "
"asLocalhost: true }"
msgstr ""

#: ../../source/developapps/application.md:179
#: ../../source/developapps/connectionoptions.md:54
#: ../../source/developapps/transactionhandler.md:63
#: ../../source/developapps/transactionhandler.md:68
#: ../../source/developapps/transactionhandler.md:73
#: ../../source/developapps/wallet.md:207
msgid "};"
msgstr ""

#: ../../source/developapps/application.md:181
msgid ""
"See how it specifies that identity, `userName`, and wallet, `wallet`, "
"should be used to connect to a gateway. These were assigned values "
"earlier in the code."
msgstr ""

#: ../../source/developapps/application.md:184
msgid ""
"There are other [connection options](./connectionoptions.html) which an "
"application could use to instruct the SDK to act intelligently on its "
"behalf. For example:"
msgstr ""

#: ../../source/developapps/application.md:190
#: ../../source/developapps/connectionoptions.md:48
msgid "identity: userName, wallet: wallet, eventHandlerOptions: {"
msgstr ""

#: ../../source/developapps/application.md:193
msgid "commitTimeout: 100, strategy: EventStrategies.MSPID_SCOPE_ANYFORTX"
msgstr ""

#: ../../source/developapps/application.md:195
msgid "},"
msgstr ""

#: ../../source/developapps/application.md:197
#: ../../source/developapps/contractname.md:66
#: ../../source/developapps/smartcontract.md:144
#: ../../source/developapps/smartcontract.md:223
#: ../../source/developapps/smartcontract.md:233
#: ../../source/developapps/smartcontract.md:248
#: ../../source/developapps/smartcontract.md:261
#: ../../source/developapps/smartcontract.md:377
#: ../../source/developapps/smartcontract.md:411
#: ../../source/developapps/smartcontract.md:437
#: ../../source/developapps/smartcontract.md:442
#: ../../source/developapps/smartcontract.md:449
#: ../../source/developapps/smartcontract.md:455
#: ../../source/developapps/smartcontract.md:477
#: ../../source/developapps/smartcontract.md:482
#: ../../source/developapps/smartcontract.md:490
#: ../../source/developapps/smartcontract.md:496
#: ../../source/developapps/smartcontract.md:548
#: ../../source/developapps/smartcontract.md:559
#: ../../source/developapps/smartcontract.md:620
#: ../../source/developapps/smartcontract.md:631
#: ../../source/developapps/smartcontract.md:657
#: ../../source/developapps/smartcontract.md:670
#: ../../source/developapps/smartcontract.md:700
#: ../../source/developapps/smartcontract.md:708
#: ../../source/developapps/transactioncontext.md:48
#: ../../source/developapps/transactioncontext.md:58
#: ../../source/developapps/transactioncontext.md:60
#: ../../source/developapps/transactionhandler.md:76
#: ../../source/developapps/transactionhandler.md:118
msgid "}"
msgstr ""

#: ../../source/developapps/application.md:199
msgid ""
"Here, `commitTimeout` tells the SDK to wait 100 seconds to hear whether a"
" transaction has been committed. And `strategy: "
"EventStrategies.MSPID_SCOPE_ANYFORTX` specifies that the SDK can notify "
"an application after a single MagnetoCorp peer has confirmed the "
"transaction, in contrast to `strategy: "
"EventStrategies.NETWORK_SCOPE_ALLFORTX` which requires that all peers "
"from MagnetoCorp and DigiBank to confirm the transaction."
msgstr ""

#: ../../source/developapps/application.md:206
msgid ""
"If you'd like to, [read more](./connectionoptions.html) about how "
"connection options allow applications to specify goal-oriented behaviour "
"without having to worry about how it is achieved."
msgstr ""

#: ../../source/developapps/application.md:210
msgid "## Network channel"
msgstr ""

#: ../../source/developapps/application.md:212
msgid ""
"The peers defined in the gateway `connectionProfile.yaml` provide "
"`issue.js` with access to PaperNet. Because these peers can be joined to "
"multiple network channels, the gateway actually provides the application "
"with access to multiple network channels!"
msgstr ""

#: ../../source/developapps/application.md:217
msgid "See how the application selects a particular channel:"
msgstr ""

#: ../../source/developapps/application.md:219
msgid "```JavaScript const network = await gateway.getNetwork('PaperNet'); ```"
msgstr ""

#: ../../source/developapps/application.md:223
msgid ""
"From this point onwards, `network` will provide access to PaperNet.  "
"Moreover, if the application wanted to access another network, `BondNet`,"
" at the same time, it is easy:"
msgstr ""

#: ../../source/developapps/application.md:227
msgid "```JavaScript const network2 = await gateway.getNetwork('BondNet'); ```"
msgstr ""

#: ../../source/developapps/application.md:231
msgid ""
"Now our application has access to a second network, `BondNet`, "
"simultaneously with `PaperNet`!"
msgstr ""

#: ../../source/developapps/application.md:234
msgid ""
"We can see here a powerful feature of Hyperledger Fabric -- applications "
"can participate in a **network of networks**, by connecting to multiple "
"gateway peers, each of which is joined to multiple network channels. "
"Applications will have different rights in different channels according "
"to their wallet identity provided in `gateway.connect()`."
msgstr ""

#: ../../source/developapps/application.md:240
msgid "## Construct request"
msgstr ""

#: ../../source/developapps/application.md:242
msgid ""
"The application is now ready to **issue** a commercial paper.  To do "
"this, it's going to use `CommercialPaperContract` and again, its fairly "
"straightforward to access this smart contract:"
msgstr ""

#: ../../source/developapps/application.md:246
msgid ""
"```JavaScript const contract = await network.getContract('papercontract',"
" 'org.papernet.commercialpaper'); ```"
msgstr ""

#: ../../source/developapps/application.md:250
msgid ""
"Note how the application provides a name -- `papercontract` -- and an "
"explicit contract name: `org.papernet.commercialpaper`! We see how a "
"[contract name](./contractname.html) picks out one contract from the "
"`papercontract.js` chaincode file that contains many contracts. In "
"PaperNet, `papercontract.js` was installed and deployed to the channel "
"with the name `papercontract`, and if you're interested, read "
"[how](../chaincode_lifecycle.html) to deploy a chaincode containing "
"multiple smart contracts."
msgstr ""

#: ../../source/developapps/application.md:258
msgid ""
"If our application simultaneously required access to another contract in "
"PaperNet or BondNet this would be easy:"
msgstr ""

#: ../../source/developapps/application.md:261
msgid ""
"```JavaScript const euroContract = await "
"network.getContract('EuroCommercialPaperContract');"
msgstr ""

#: ../../source/developapps/application.md:264
msgid "const bondContract = await network2.getContract('BondContract'); ```"
msgstr ""

#: ../../source/developapps/application.md:267
msgid ""
"In these examples, note how we didn't use a qualifying contract name -- "
"we have only one smart contract per file, and `getContract()` will use "
"the first contract it finds."
msgstr ""

#: ../../source/developapps/application.md:271
msgid ""
"Recall the transaction MagnetoCorp uses to issue its first commercial "
"paper:"
msgstr ""

#: ../../source/developapps/application.md:282
msgid "Let's now submit this transaction to PaperNet!"
msgstr ""

#: ../../source/developapps/application.md:284
msgid "## Submit transaction"
msgstr ""

#: ../../source/developapps/application.md:286
msgid "Submitting a transaction is a single method call to the SDK:"
msgstr ""

#: ../../source/developapps/application.md:288
msgid ""
"```JavaScript const issueResponse = await "
"contract.submitTransaction('issue', 'MagnetoCorp', '00001', '2020-05-31',"
" '2020-11-30', '5000000'); ```"
msgstr ""

#: ../../source/developapps/application.md:292
msgid ""
"See how the `submitTransaction()` parameters match those of the "
"transaction request.  It's these values that will be passed to the "
"`issue()` method in the smart contract, and used to create a new "
"commercial paper.  Recall its signature:"
msgstr ""

#: ../../source/developapps/application.md:297
msgid ""
"```JavaScript async issue(ctx, issuer, paperNumber, issueDateTime, "
"maturityDateTime, faceValue) {...} ```"
msgstr ""

#: ../../source/developapps/application.md:301
msgid ""
"It might appear that a smart contract receives control shortly after the "
"application issues `submitTransaction()`, but that's not the case. Under "
"the covers, the SDK uses the `connectionOptions` and `connectionProfile` "
"details to send the transaction proposal to the right peers in the "
"network, where it can get the required endorsements. But the application "
"doesn't need to worry about any of this -- it just issues "
"`submitTransaction` and the SDK takes care of it all!"
msgstr ""

#: ../../source/developapps/application.md:309
msgid ""
"Note that the `submitTransaction` API includes a process for listening "
"for transaction commits. Listening for commits is required because "
"without it, you will not know whether your transaction has successfully "
"been orderered, validated, and committed to the ledger."
msgstr ""

#: ../../source/developapps/application.md:314
msgid "Let's now turn our attention to how the application handles the response!"
msgstr ""

#: ../../source/developapps/application.md:316
msgid "## Process response"
msgstr ""

#: ../../source/developapps/application.md:318
msgid ""
"Recall from `papercontract.js` how the **issue** transaction returns a "
"commercial paper response:"
msgstr ""

#: ../../source/developapps/application.md:321
msgid "```JavaScript return paper.toBuffer(); ```"
msgstr ""

#: ../../source/developapps/application.md:325
msgid ""
"You'll notice a slight quirk -- the new `paper` needs to be converted to "
"a buffer before it is returned to the application. Notice how `issue.js` "
"uses the class method `CommercialPaper.fromBuffer()` to rehydrate the "
"response buffer as a commercial paper:"
msgstr ""

#: ../../source/developapps/application.md:330
msgid "```JavaScript let paper = CommercialPaper.fromBuffer(issueResponse); ```"
msgstr ""

#: ../../source/developapps/application.md:334
msgid ""
"This allows `paper` to be used in a natural way in a descriptive "
"completion message:"
msgstr ""

#: ../../source/developapps/application.md:337
msgid ""
"```JavaScript console.log(`${paper.issuer} commercial paper : "
"${paper.paperNumber} successfully issued for value ${paper.faceValue}`); "
"```"
msgstr ""

#: ../../source/developapps/application.md:341
msgid ""
"See how the same `paper` class has been used in both the application and "
"smart contract -- if you structure your code like this, it'll really help"
" readability and reuse."
msgstr ""

#: ../../source/developapps/application.md:345
msgid ""
"As with the transaction proposal, it might appear that the application "
"receives control soon after the smart contract completes, but that's not "
"the case. Under the covers, the SDK manages the entire consensus process,"
" and notifies the application when it is complete according to the "
"`strategy` connectionOption. If you're interested in what the SDK does "
"under the covers, read the detailed [transaction "
"flow](../../txflow.html)."
msgstr ""

#: ../../source/developapps/application.md:352
msgid ""
"That’s it! In this topic you’ve understood how to call a smart contract "
"from a sample application by examining how MagnetoCorp's application "
"issues a new commercial paper in PaperNet. Now examine the key ledger and"
" smart contract data structures are designed by in the [architecture "
"topic](./architecture.html) behind them."
msgstr ""

#: ../../source/developapps/architecture.md:1
msgid "# Process and Data Design"
msgstr ""

#: ../../source/developapps/architecture.md:6
msgid ""
"This topic shows you how to design the commercial paper processes and "
"their related data structures in PaperNet. Our "
"[analysis](./analysis.html) highlighted that modelling PaperNet using "
"states and transactions provided a precise way to understand what's "
"happening. We're now going to elaborate on these two strongly related "
"concepts to help us subsequently design the smart contracts and "
"applications of PaperNet."
msgstr ""

#: ../../source/developapps/architecture.md:13
msgid "## Lifecycle"
msgstr ""

#: ../../source/developapps/architecture.md:15
msgid ""
"As we've seen, there are two important concepts that concern us when "
"dealing with commercial paper; **states** and **transactions**. Indeed, "
"this is true for *all* blockchain use cases; there are conceptual objects"
" of value, modeled as states, whose lifecycle transitions are described "
"by transactions. An effective analysis of states and transactions is an "
"essential starting point for a successful implementation."
msgstr ""

#: ../../source/developapps/architecture.md:22
msgid ""
"We can represent the life cycle of a commercial paper using a state "
"transition diagram:"
msgstr ""

#: ../../source/developapps/architecture.md:25
msgid ""
"![develop.statetransition](./develop.diagram.4.png) *The state transition"
" diagram for commercial paper. Commercial papers transition between "
"**issued**, **trading** and **redeemed** states by means of the "
"**issue**, **buy** and **redeem** transactions.*"
msgstr ""

#: ../../source/developapps/architecture.md:30
msgid ""
"See how the state diagram describes how commercial papers change over "
"time, and how specific transactions govern the life cycle transitions. In"
" Hyperledger Fabric, smart contracts implement transaction logic that "
"transition commercial papers between their different states. Commercial "
"paper states are actually held in the ledger world state; so let's take a"
" closer look at them."
msgstr ""

#: ../../source/developapps/architecture.md:36
msgid "## Ledger state"
msgstr ""

#: ../../source/developapps/architecture.md:38
msgid "Recall the structure of a commercial paper:"
msgstr ""

#: ../../source/developapps/architecture.md:40
msgid ""
"![develop.paperstructure](./develop.diagram.5.png) *A commercial paper "
"can be represented as a set of properties, each with a value. Typically, "
"some combination of these properties will provide a unique key for each "
"paper.*"
msgstr ""

#: ../../source/developapps/architecture.md:44
msgid ""
"See how a commercial paper `Paper` property has value `00001`, and the "
"`Face value` property has value `5M USD`. Most importantly, the `Current "
"state` property indicates whether the commercial paper is "
"`issued`,`trading` or `redeemed`. In combination, the full set of "
"properties make up the **state** of a commercial paper. Moreover, the "
"entire collection of these individual commercial paper states constitutes"
" the ledger [world state](../ledger/ledger.html#world-state)."
msgstr ""

#: ../../source/developapps/architecture.md:52
msgid ""
"All ledger state share this form; each has a set of properties, each with"
" a different value. This *multi-property* aspect of states is a powerful "
"feature -- it allows us to think of a Fabric state as a vector rather "
"than a simple scalar. We then represent facts about whole objects as "
"individual states, which subsequently undergo transitions controlled by "
"transaction logic. A Fabric state is implemented as a key/value pair, in "
"which the value encodes the object properties in a format that captures "
"the object's multiple properties, typically JSON. The [ledger "
"database](../ledger/ledger.html#ledger-world-state-database-options) can "
"support advanced query operations against these properties, which is very"
" helpful for sophisticated object retrieval."
msgstr ""

#: ../../source/developapps/architecture.md:64
msgid ""
"See how MagnetoCorp's paper `00001` is represented as a state vector that"
" transitions according to different transaction stimuli:"
msgstr ""

#: ../../source/developapps/architecture.md:67
msgid ""
"![develop.paperstates](./develop.diagram.6.png) *A commercial paper state"
" is brought into existence and transitions as a result of different "
"transactions. Hyperledger Fabric states have multiple properties, making "
"them vectors rather than scalars.*"
msgstr ""

#: ../../source/developapps/architecture.md:72
msgid ""
"Notice how each individual paper starts with the empty state, which is "
"technically a [`nil`](https://en.wikipedia.org/wiki/Null_(SQL)) state for"
" the paper, as it doesn't exist! See how paper `00001` is brought into "
"existence by the **issue** transaction, and how it is subsequently "
"updated as a result of the **buy** and **redeem** transactions."
msgstr ""

#: ../../source/developapps/architecture.md:78
msgid ""
"Notice how each state is self-describing; each property has a name and a "
"value. Although all our commercial papers currently have the same "
"properties, this need not be the case for all time, as Hyperledger Fabric"
" supports different states having different properties. This allows the "
"same ledger world state to contain different forms of the same asset as "
"well as different types of asset. It also makes it possible to update a "
"state's structure; imagine a new regulation that requires an additional "
"data field. Flexible state properties support the fundamental requirement"
" of data evolution over time."
msgstr ""

#: ../../source/developapps/architecture.md:87
msgid "## State keys"
msgstr ""

#: ../../source/developapps/architecture.md:89
msgid ""
"In most practical applications, a state will have a combination of "
"properties that uniquely identify it in a given context -- it's **key**. "
"The key for a PaperNet commercial paper is formed by a concatenation of "
"the `Issuer` and `paper` properties; so for MagnetoCorp's first paper, "
"it's `MagnetoCorp00001`."
msgstr ""

#: ../../source/developapps/architecture.md:94
msgid ""
"A state key allows us to uniquely identify a paper; it is created as a "
"result of the **issue** transaction and subsequently updated by **buy** "
"and **redeem**. Hyperledger Fabric requires each state in a ledger to "
"have a unique key."
msgstr ""

#: ../../source/developapps/architecture.md:98
msgid ""
"When a unique key is not available from the available set of properties, "
"an application-determined unique key is specified as an input to the "
"transaction that creates the state. This unique key is usually with some "
"form of "
"[UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), "
"which although less readable, is a standard practice. What's important is"
" that every individual state object in a ledger must have a unique key."
msgstr ""

#: ../../source/developapps/architecture.md:105
msgid "_Note: You should avoid using U+0000 (nil byte) in keys._"
msgstr ""

#: ../../source/developapps/architecture.md:107
msgid "## Multiple states"
msgstr ""

#: ../../source/developapps/architecture.md:109
msgid ""
"As we've seen, commercial papers in PaperNet are stored as state vectors "
"in a ledger. It's a reasonable requirement to be able to query different "
"commercial papers from the ledger; for example: find all the papers "
"issued by MagnetoCorp, or: find all the papers issued by MagnetoCorp in "
"the `redeemed` state."
msgstr ""

#: ../../source/developapps/architecture.md:114
msgid ""
"To make these kinds of search tasks possible, it's helpful to group all "
"related papers together in a logical list. The PaperNet design "
"incorporates the idea of a commercial paper list -- a logical container "
"which is updated whenever commercial papers are issued or otherwise "
"changed."
msgstr ""

#: ../../source/developapps/architecture.md:119
msgid "### Logical representation"
msgstr ""

#: ../../source/developapps/architecture.md:121
msgid ""
"It's helpful to think of all PaperNet commercial papers being in a single"
" list of commercial papers:"
msgstr ""

#: ../../source/developapps/architecture.md:124
msgid ""
"![develop.paperlist](./develop.diagram.7.png) *MagnetoCorp's newly "
"created commercial  paper 00004 is added to the list of existing "
"commercial papers.*"
msgstr ""

#: ../../source/developapps/architecture.md:128
msgid ""
"New papers can be added to the list as a result of an **issue** "
"transaction, and papers already in the list can be updated with **buy** "
"or **redeem** transactions. See how the list has a descriptive name: "
"`org.papernet.papers`; it's a really good idea to use this kind of [DNS "
"name](https://en.wikipedia.org/wiki/Domain_Name_System) because well-"
"chosen names will make your blockchain designs intuitive to other people."
" This idea applies equally well to smart contract "
"[names](./contractname.html)."
msgstr ""

#: ../../source/developapps/architecture.md:136
msgid "### Physical representation"
msgstr ""

#: ../../source/developapps/architecture.md:138
msgid ""
"While it's correct to think of a single list of papers in PaperNet -- "
"`org.papernet.papers` -- lists are best implemented as a set of "
"individual Fabric states, whose composite key associates the state with "
"its list. In this way, each state's composite key is both unique and "
"supports effective list query."
msgstr ""

#: ../../source/developapps/architecture.md:143
msgid ""
"![develop.paperphysical](./develop.diagram.8.png) *Representing a list of"
" PaperNet commercial papers as a set of distinct Hyperledger Fabric "
"states*"
msgstr ""

#: ../../source/developapps/architecture.md:146
msgid ""
"Notice how each paper in the list is represented by a vector state, with "
"a unique **composite** key formed by the concatenation of "
"`org.papernet.paper`, `Issuer` and `Paper` properties. This structure is "
"helpful for two reasons:"
msgstr ""

#: ../../source/developapps/architecture.md:150
msgid ""
"It allows us to examine any state vector in the ledger to determine which"
" list it's in, without reference to a separate list. It's analogous to "
"looking at set of sports fans, and identifying which team they support by"
" the colour of the shirt they are wearing. The sports fans self-declare "
"their allegiance; we don't need a list of fans."
msgstr ""

#: ../../source/developapps/architecture.md:157
msgid ""
"Hyperledger Fabric internally uses a concurrency control mechanism <!-- "
"Add more information to explain this topic--> to update a ledger, such "
"that keeping papers in separate state vectors vastly reduces the "
"opportunity for shared-state collisions. Such collisions require "
"transaction re-submission, complicate application design, and decrease "
"performance."
msgstr ""

#: ../../source/developapps/architecture.md:164
msgid ""
"This second point is actually a key take-away for Hyperledger Fabric; the"
" physical design of state vectors is **very important** to optimum "
"performance and behaviour. Keep your states separate!"
msgstr ""

#: ../../source/developapps/architecture.md:168
msgid "## Trust relationships"
msgstr ""

#: ../../source/developapps/architecture.md:170
msgid ""
"We have discussed how the different roles in a network, such as issuer, "
"trader or rating agencies as well as different business interests "
"determine who needs to sign off on a transaction. In Fabric, these rules "
"are captured by so-called [**endorsement "
"policies**](endorsementpolicies.html). The rules can be set on a "
"chaincode granularity, as well as for individual state keys."
msgstr ""

#: ../../source/developapps/architecture.md:176
msgid ""
"This means that in PaperNet, we can set one rule for the whole namespace "
"that determines which organizations can issue new papers. Later, rules "
"can be set and updated for individual papers to capture the trust "
"relationships of buy and redeem transactions."
msgstr ""

#: ../../source/developapps/architecture.md:182
msgid ""
"In the next topic, we will show you how to combine these design concepts "
"to implement the PaperNet commercial paper smart contract, and then an "
"application in exploits it!"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:1
msgid "# Chaincode namespace"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:3
#: ../../source/developapps/contractname.md:3
msgid ""
"**Audience**: Architects, application and smart contract developers, "
"administrators"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:6
msgid ""
"A chaincode namespace allows it to keep its world state separate from "
"other chaincodes. Specifically, smart contracts in the same chaincode "
"share direct access to the same world state, whereas smart contracts in "
"different chaincodes cannot directly access each other's world state. If "
"a smart contract needs to access another chaincode world state, it can do"
" this by performing a chaincode-to-chaincode invocation. Finally, a "
"blockchain can contain transactions which relate to different world "
"states."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:16
msgid "[The importance of namespaces](#motivation)"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:17
msgid "[What is a chaincode namespace](#scenario)"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:18
msgid "[Channels and namespaces](#channels)"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:19
msgid "[How to use chaincode namespaces](#usage)"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:20
msgid ""
"[How to access world states across smart contracts](#cross-chaincode-"
"access)"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:21
msgid "[Design considerations for chaincode namespaces](#considerations)"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:23
msgid "## Motivation"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:25
msgid ""
"A namespace is a common concept. We understand that *Park Street, New "
"York* and *Park Street, Seattle* are different streets even though they "
"have the same name. The city forms a **namespace** for Park Street, "
"simultaneously providing freedom and clarity."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:30
msgid ""
"It's the same in a computer system. Namespaces allow different users to "
"program and operate different parts of a shared system, without getting "
"in each other's way. Many programming languages have namespaces so that "
"programs can freely assign unique identifiers, such as variable names, "
"without worrying about other programs doing the same. We'll see that "
"Hyperledger Fabric uses namespaces to help smart contracts keep their "
"ledger world state separate from other smart contracts."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:38
#: ../../source/developapps/connectionoptions.md:17
#: ../../source/developapps/connectionprofile.md:19
#: ../../source/developapps/gateway.md:17
#: ../../source/developapps/transactioncontext.md:24
#: ../../source/developapps/wallet.md:17
msgid "## Scenario"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:40
msgid ""
"Let's examine how the ledger world state organizes facts about business "
"objects that are important to the organizations in a channel using the "
"diagram below. Whether these objects are commercial papers, bonds, or "
"vehicle registrations, and wherever they are in their lifecycle, they are"
" maintained as states within the ledger world state database. A smart "
"contract manages these business objects by interacting with the ledger "
"(world state and blockchain), and in most cases this will involve it "
"querying or updating the ledger world state."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:48
msgid ""
"It's vitally important to understand that the ledger world state is "
"partitioned according to the chaincode of the smart contract that "
"accesses it, and this partitioning, or *namespacing* is an important "
"design consideration for architects, administrators and programmers."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:53
msgid ""
"![chaincodens.scenario](./develop.diagram.50.png) *The ledger world state"
" is separated into different namespaces according to the chaincode that "
"accesses it. Within a given channel, smart contracts in the same "
"chaincode share the same world state, and smart contracts in different "
"chaincodes cannot directly access each other's world state. Likewise, a "
"blockchain can contain transactions that relate to different chaincode "
"world states.*"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:60
msgid ""
"In our example, we can see four smart contracts defined in two different "
"chaincodes, each of which is in their own chaincode container. The "
"`euroPaper` and `yenPaper` smart contracts are defined in the `papers` "
"chaincode. The situation is similar for the `euroBond` and `yenBond` "
"smart contracts  -- they are defined in the `bonds` chaincode. This "
"design helps application programmers understand whether they are working "
"with commercial papers or bonds priced in Euros or Yen, and because the "
"rules for each financial product don't really change for different "
"currencies, it makes sense to manage their deployment in the same "
"chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:70
msgid ""
"The [diagram](#scenario) also shows the consequences of this deployment "
"choice. The database management system (DBMS) creates different world "
"state databases for the `papers` and `bonds` chaincodes and the smart "
"contracts contained within them. `World state A` and `world state B` are "
"each held within distinct databases; the data are isolated from each "
"other such that a single world state query (for example) cannot access "
"both world states. The world state is said to be *namespaced* according "
"to its chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:78
msgid ""
"See how `world state A` contains two lists of commercial papers "
"`paperListEuro` and `paperListYen`. The states `PAP11` and `PAP21` are "
"instances of each paper managed by the `euroPaper` and `yenPaper` smart "
"contracts respectively. Because they share the same chaincode namespace, "
"their keys (`PAPxyz`) must be unique within the namespace of the `papers`"
" chaincode, a little like a street name is unique within a town. Notice "
"how it would be possible to write a smart contract in the `papers` "
"chaincode that performed an aggregate calculation over all the commercial"
" papers -- whether priced in Euros or Yen -- because they share the same "
"namespace. The situation is similar for bonds -- they are held within "
"`world state B` which maps to a separate `bonds` database, and their keys"
" must be unique."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:90
msgid ""
"Just as importantly, namespaces mean that `euroPaper` and `yenPaper` "
"cannot directly access `world state B`, and that `euroBond` and `yenBond`"
" cannot directly access `world state A`. This isolation is helpful, as "
"commercial papers and bonds are very distinct financial instruments; they"
" have different attributes and are subject to different rules. It also "
"means that `papers` and `bonds` could have the same keys, because they "
"are in different namespaces. This is helpful; it provides a significant "
"degree of freedom for naming. Use this freedom to name different business"
" objects meaningfully."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:99
msgid ""
"Most importantly, we can see that a blockchain is associated with the "
"peer operating in a particular channel, and that it contains transactions"
" that affect both `world state A` and `world state B`. That's because the"
" blockchain is the most fundamental data structure contained in a peer. "
"The set of world states can always be recreated from this blockchain, "
"because they are the cumulative results of the blockchain's transactions."
" A world state helps simplify smart contracts and improve their "
"efficiency, as they usually only require the current value of a state. "
"Keeping world states separate via namespaces helps smart contracts "
"isolate their logic from other smart contracts, rather than having to "
"worry about transactions that correspond to different world states. For "
"example, a `bonds` contract does not need to worry about `paper` "
"transactions, because it cannot see their resultant world state."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:112
msgid ""
"It's also worth noticing that the peer, chaincode containers and DBMS all"
" are logically different processes. The peer and all its chaincode "
"containers are always in physically separate operating system processes, "
"but the DBMS can be configured to be embedded or separate, depending on "
"its [type](../ledger/ledger.html#world-state-database-options). For "
"LevelDB, the DBMS is wholly contained within the peer, but for CouchDB, "
"it is a separate operating system process."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:120
msgid ""
"It's important to remember that namespace choices in this example are the"
" result of a business requirement to share commercial papers in different"
" currencies but isolate them separate from bonds. Think about how the "
"namespace structure would be modified to meet a business requirement to "
"keep every financial asset class separate, or share all commercial papers"
" and bonds?"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:126
msgid "## Channels"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:128
msgid ""
"If a peer is joined to multiple channels, then a new blockchain is "
"created and managed for each channel. Moreover, every time a chaincode is"
" deployed to a new channel, a new world state database is created for it."
" It means that the channel also forms a kind of namespace alongside that "
"of the chaincode for the world state."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:134
msgid ""
"However, the same peer and chaincode container processes can be "
"simultaneously joined to multiple channels -- unlike blockchains, and "
"world state databases, these processes do not increase with the number of"
" channels joined."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:138
msgid ""
"For example, if you deployed the `papers` and `bonds` chaincode to a new "
"channel, there would a totally separate blockchain created, and two new "
"world state databases created. However, the peer and chaincode containers"
" would not increase; each would just be connected to multiple channels."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:143
#: ../../source/developapps/connectionoptions.md:37
#: ../../source/developapps/connectionprofile.md:71
msgid "## Usage"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:145
msgid ""
"Let's use our commercial paper [example](#scenario) to show how an "
"application uses a smart contract with namespaces. It's worth noting that"
" an application communicates with the peer, and the peer routes the "
"request to the appropriate chaincode container which then accesses the "
"DBMS. This routing is done by the peer **core** component shown in the "
"diagram."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:151
msgid ""
"Here's the code for an application that uses both commercial papers and "
"bonds, priced in Euros and Yen. The code is fairly self-explanatory:"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:154
msgid ""
"```javascript const euroPaper = network.getContract(papers, euroPaper); "
"paper1 = euroPaper.submit(issue, PAP11);"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:158
msgid ""
"const yenPaper = network.getContract(papers, yenPaper); paper2 = "
"yenPaper.submit(redeem, PAP21);"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:161
msgid ""
"const euroBond = network.getContract(bonds, euroBond); bond1 = "
"euroBond.submit(buy, BON31);"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:164
msgid ""
"const yenBond = network.getContract(bonds, yenBond); bond2 = "
"yenBond.submit(sell, BON41); ```"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:168
msgid "See how the application:"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:170
msgid ""
"Accesses the `euroPaper` and `yenPaper` contracts using the "
"`getContract()` API specifying the `papers` chaincode. See interaction "
"points **1a** and **2a**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:174
msgid ""
"Accesses the `euroBond` and `yenBond` contracts using the `getContract()`"
" API specifying the `bonds` chaincode. See interaction points **3a** and "
"**4a**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:177
msgid ""
"Submits an `issue` transaction to the network for commercial paper "
"`PAP11` using the `euroPaper` contract. See interaction point **1a**. "
"This results in the creation of a commercial paper represented by state "
"`PAP11` in `world state A`; interaction point **1b**. This operation is "
"captured as a transaction in the blockchain at interaction point **1c**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:183
msgid ""
"Submits a `redeem` transaction to the network for commercial paper "
"`PAP21` using the `yenPaper` contract. See interaction point **2a**. This"
" results in the creation of a commercial paper represented by state "
"`PAP21` in `world state A`; interaction point **2b**. This operation is "
"captured as a transaction in the blockchain at interaction point **2c**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:189
msgid ""
"Submits a `buy` transaction to the network for bond `BON31` using the "
"`euroBond` contract. See interaction point **3a**. This results in the "
"creation of a bond represented by state `BON31` in `world state B`; "
"interaction point **3b**. This operation is captured as a transaction in "
"the blockchain at interaction point **3c**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:195
msgid ""
"Submits a `sell` transaction to the network for bond `BON41` using the "
"`yenBond` contract. See interaction point **4a**. This results in the "
"creation of a bond represented by state `BON41` in `world state B`; "
"interaction point **4b**. This operation is captured as a transaction in "
"the blockchain at interaction point **4c**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:202
msgid "See how smart contracts interact with the world state:"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:204
msgid ""
"`euroPaper` and `yenPaper` contracts can directly access `world state A`,"
" but cannot directly access `world state B`. `World state A` is "
"physically held in the `papers` database in the database management "
"system (DBMS) corresponding to the `papers` chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:209
msgid ""
"`euroBond` and `yenBond` contracts can directly access `world state B`, "
"but cannot directly access `world state A`. `World state B` is physically"
" held in the `bonds` database in the database management system (DBMS) "
"corresponding to the `bonds` chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:215
msgid "See how the blockchain captures transactions for all world states:"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:217
msgid ""
"Interactions **1c** and **2c** correspond to transactions create and "
"update commercial papers `PAP11` and `PAP21` respectively. These are both"
" contained within `world state A`."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:221
msgid ""
"Interactions **3c** and **4c** correspond to transactions both update "
"bonds `BON31` and `BON41`. These are both contained within `world state "
"B`."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:224
msgid ""
"If `world state A` or `world state B` were destroyed for any reason, they"
" could be recreated by replaying all the transactions in the blockchain."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:228
msgid "## Cross chaincode access"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:230
msgid ""
"As we saw in our example [scenario](#scenario), `euroPaper` and "
"`yenPaper` cannot directly access `world state B`.  That's because we "
"have designed our chaincodes and smart contracts so that these chaincodes"
" and world states are kept separately from each other.  However, let's "
"imagine that `euroPaper` needs to access `world state B`."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:236
msgid ""
"Why might this happen? Imagine that when a commercial paper was issued, "
"the smart contract wanted to price the paper according to the current "
"return on bonds with a similar maturity date.  In this case it will be "
"necessary for the `euroPaper` contract to be able to query the price of "
"bonds in `world state B`. Look at the following diagram to see how we "
"might structure this interaction."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:242
msgid ""
"![chaincodens.scenario](./develop.diagram.51.png) *How chaincodes and "
"smart contracts can indirectly access another world state -- via its "
"chaincode.*"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:245
#: ../../source/developapps/wallet.md:212
msgid "Notice how:"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:247
msgid ""
"the application submits an `issue` transaction in the `euroPaper` smart "
"contract to issue `PAP11`. See interaction **1a**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:250
msgid ""
"the `issue` transaction in the `euroPaper` smart contract calls the "
"`query` transaction in the `euroBond` smart contract. See interaction "
"point **1b**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:254
msgid ""
"the `query`in `euroBond` can retrieve information from `world state B`. "
"See"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:254
msgid "interaction point **1c**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:256
msgid ""
"when control returns to the `issue` transaction, it can use the "
"information in the response to price the paper and update `world state A`"
" with information. See interaction point **1d**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:260
msgid ""
"the flow of control for issuing commercial paper priced in Yen is the "
"same. See interaction points **2a**, **2b**, **2c** and **2d**."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:263
msgid ""
"Control is passed between chaincode using the `invokeChaincode()` "
"[API](https://hyperledger.github.io/fabric-chaincode-node/master/api"
"/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor)."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:266
msgid "This API passes control from one chaincode to another chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:268
msgid ""
"Although we have only discussed query transactions in the example, it is "
"possible to invoke a smart contract which will update the called "
"chaincode's world state.  See the [considerations](#considerations) "
"below."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:272
#: ../../source/developapps/connectionoptions.md:198
msgid "## Considerations"
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:274
msgid "In general, each chaincode will have a single smart contract in it."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:276
msgid ""
"Multiple smart contracts should only be deployed in the same chaincode if"
" they are very closely related.  Usually, this is only necessary if they "
"share the same world state."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:280
msgid ""
"Chaincode namespaces provide isolation between different world states. In"
" general it makes sense to isolate unrelated data from each other. Note "
"that you cannot choose the chaincode namespace; it is assigned by "
"Hyperledger Fabric, and maps directly to the name of the chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:285
msgid ""
"For chaincode to chaincode interactions using the `invokeChaincode()` "
"API, both chaincodes must be installed on the same peer."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:288
msgid ""
"For interactions that only require the called chaincode's world state to "
"be queried, the invocation can be in a different channel to the caller's "
"chaincode."
msgstr ""

#: ../../source/developapps/chaincodenamespace.md:292
msgid ""
"For interactions that require the called chaincode's world state to be "
"updated, the invocation must be in the same channel as the caller's "
"chaincode."
msgstr ""

#: ../../source/developapps/connectionoptions.md:1
msgid "# Connection Options"
msgstr ""

#: ../../source/developapps/connectionoptions.md:3
msgid ""
"**Audience**: Architects, administrators, application and smart contract "
"developers"
msgstr ""

#: ../../source/developapps/connectionoptions.md:6
msgid ""
"Connection options are used in conjunction with a connection profile to "
"control *precisely* how a gateway interacts with a network. Using a "
"gateway allows an application to focus on business logic rather than "
"network topology."
msgstr ""

#: ../../source/developapps/connectionoptions.md:12
msgid "[Why connection options are important](#scenario)"
msgstr ""

#: ../../source/developapps/connectionoptions.md:13
msgid "[How an application uses connection options](#usage)"
msgstr ""

#: ../../source/developapps/connectionoptions.md:14
msgid "[What each connection option does](#options)"
msgstr ""

#: ../../source/developapps/connectionoptions.md:15
msgid "[When to use a particular connection option](#considerations)"
msgstr ""

#: ../../source/developapps/connectionoptions.md:19
msgid ""
"A connection option specifies a particular aspect of a gateway's "
"behaviour. Gateways are important for [many reasons](./gateway.html), the"
" primary being to allow an application to focus on business logic and "
"smart contracts, while it manages interactions with the many components "
"of a network."
msgstr ""

#: ../../source/developapps/connectionoptions.md:24
msgid ""
"![profile.scenario](./develop.diagram.35.png) *The different interaction "
"points where connection options control behaviour. These options are "
"explained fully in the text.*"
msgstr ""

#: ../../source/developapps/connectionoptions.md:28
msgid ""
"One example of a connection option might be to specify that the gateway "
"used by the `issue` application should use identity `Isabella` to submit "
"transactions to the `papernet` network. Another might be that a gateway "
"should wait for all three nodes from MagnetoCorp to confirm a transaction"
" has been committed returning control. Connection options allow "
"applications to specify the precise behaviour of a gateway's interaction "
"with the network. Without a gateway, applications need to do a lot more "
"work; gateways save you time, make your application more readable, and "
"less error prone."
msgstr ""

#: ../../source/developapps/connectionoptions.md:39
msgid ""
"We'll describe the [full set](#options) of connection options available "
"to an application in a moment; let's first see how they are specified by "
"the sample MagnetoCorp `issue` application:"
msgstr ""

#: ../../source/developapps/connectionoptions.md:43
msgid ""
"```javascript const userName = 'User1@org1.example.com'; const wallet = "
"new FileSystemWallet('../identity/user/isabella/wallet');"
msgstr ""

#: ../../source/developapps/connectionoptions.md:54
msgid "const connectionOptions = {"
msgstr ""

#: ../../source/developapps/connectionoptions.md:51
msgid "commitTimeout: 100, strategy: EventStrategies.MSPID_SCOPE_ANYFORTX }"
msgstr ""

#: ../../source/developapps/connectionoptions.md:56
#: ../../source/developapps/connectionprofile.md:84
msgid "await gateway.connect(connectionProfile, connectionOptions); ```"
msgstr ""

#: ../../source/developapps/connectionoptions.md:59
msgid ""
"See how the `identity` and `wallet` options are simple properties of the "
"`connectionOptions` object. They have values `userName` and `wallet` "
"respectively, which were set earlier in the code. Contrast these options "
"with the `eventHandlerOptions` option which is an object in its own "
"right. It has two properties: `commitTimeout: 100` (measured in seconds) "
"and `strategy: EventStrategies.MSPID_SCOPE_ANYFORTX`."
msgstr ""

#: ../../source/developapps/connectionoptions.md:66
msgid ""
"See how `connectionOptions` is passed to a gateway as a complement to "
"`connectionProfile`; the network is identified by the connection profile "
"and the options specify precisely how the gateway should interact with "
"it. Let's now look at the available options."
msgstr ""

#: ../../source/developapps/connectionoptions.md:71
msgid "## Options"
msgstr ""

#: ../../source/developapps/connectionoptions.md:73
msgid "Here's a list of the available options and what they do."
msgstr ""

#: ../../source/developapps/connectionoptions.md:75
msgid ""
"`wallet` identifies the wallet that will be used by the gateway on behalf"
" of the application. See interaction **1**; the wallet is specified by "
"the application, but it's actually the gateway that retrieves identities "
"from it."
msgstr ""

#: ../../source/developapps/connectionoptions.md:79
msgid ""
"A wallet must be specified; the most important decision is the "
"[type](./wallet.html#type) of wallet to use, whether that's file system, "
"in-memory, HSM or database."
msgstr ""

#: ../../source/developapps/connectionoptions.md:84
msgid ""
"`identity` is the user identity that the application will use from "
"`wallet`. See interaction **2a**; the user identity is specified by the "
"application and represents the user of the application, Isabella, **2b**."
" The identity is actually retrieved by the gateway."
msgstr ""

#: ../../source/developapps/connectionoptions.md:89
msgid ""
"In our example, Isabella's identity will be used by different MSPs "
"(**2c**, **2d**) to identify her as being from MagnetoCorp, and having a "
"particular role within it. These two facts will correspondingly determine"
" her permission over resources, such as being able to read and write the "
"ledger, for example."
msgstr ""

#: ../../source/developapps/connectionoptions.md:94
msgid ""
"A user identity must be specified. As you can see, this identity is "
"fundamental to the idea that Hyperledger Fabric is a *permissioned* "
"network -- all actors have an identity, including applications, peers and"
" orderers, which determines their control over resources. You can read "
"more about this idea in the membership services "
"[topic](../membership/membership.html)."
msgstr ""

#: ../../source/developapps/connectionoptions.md:100
msgid ""
"`clientTlsIdentity` is the identity that is retrieved from a wallet "
"(**3a**) and used for secure communications (**3b**) between the gateway "
"and different channel components, such as peers and orderers."
msgstr ""

#: ../../source/developapps/connectionoptions.md:104
msgid ""
"Note that this identity is different to the user identity.  Even though "
"`clientTlsIdentity` is important for secure communications, it is not as "
"foundational as the user identity because its scope does not extend "
"beyond secure network communications."
msgstr ""

#: ../../source/developapps/connectionoptions.md:109
msgid ""
"`clientTlsIdentity` is optional. You are advised to set it in production "
"environments. You should always use a different `clientTlsIdentity` to "
"`identity` because these identities have very different meanings and "
"lifecycles. For example, if your `clientTlsIdentity` was compromised, "
"then so would your `identity`; it's more secure to keep them separate."
msgstr ""

#: ../../source/developapps/connectionoptions.md:122
msgid ""
"`eventHandlerOptions.commitTimeout` is optional. It specifies, in "
"seconds, the"
msgstr ""

#: ../../source/developapps/connectionoptions.md:117
msgid ""
"maximum amount of time the gateway should wait for a transaction to be "
"committed by any peer (**4a**) before returning control to the "
"application. The set of peers to use for notification is determined by "
"the `eventHandlerOptions.strategy` option. If a commitTimeout is not "
"specified, the gateway will use a timeout of 300 seconds."
msgstr ""

#: ../../source/developapps/connectionoptions.md:127
msgid "`eventHandlerOptions.strategy` is optional. It identifies the set of peers"
msgstr ""

#: ../../source/developapps/connectionoptions.md:125
msgid ""
"that a gateway should use to listen for notification that a transaction "
"has been committed. For example, whether to listen for a single peer, or "
"all peers, from its organization. It can take one of the following "
"values:"
msgstr ""

#: ../../source/developapps/connectionoptions.md:129
msgid ""
"`EventStrategies.MSPID_SCOPE_ANYFORTX` Listen for **any** peer within the"
" user's organization. In our example, see interaction points **4b**; any "
"of peer 1, peer 2 or peer 3 from MagnetoCorp can notify the gateway."
msgstr ""

#: ../../source/developapps/connectionoptions.md:138
msgid ""
"`EventStrategies.MSPID_SCOPE_ALLFORTX` **This is the default value**. "
"Listen"
msgstr ""

#: ../../source/developapps/connectionoptions.md:134
msgid ""
"for **all** peers within the user's organization. In our example peer, "
"see interaction point **4b**. All peers from MagnetoCorp must all have "
"notified the gateway; peer 1, peer 2 and peer 3. Peers are only counted "
"if they are known/discovered and available; peers that are stopped or "
"have failed are not included."
msgstr ""

#: ../../source/developapps/connectionoptions.md:140
msgid ""
"`EventStrategies.NETWORK_SCOPE_ANYFORTX` Listen for **any** peer within "
"the entire network channel. In our example, see interaction points **4b**"
" and **4c**; any of peer 1-3 from MagnetoCorp or peer 7-9 of DigiBank can"
" notify the gateway."
msgstr ""

#: ../../source/developapps/connectionoptions.md:145
msgid ""
"`EventStrategies.NETWORK_SCOPE_ALLFORTX` Listen for **all** peers within "
"the entire network channel. In our example, see interaction points **4b**"
" and **4c**. All peers from MagnetoCorp and DigiBank must notify the "
"gateway; peers 1-3 and peers 7-9. Peers are only counted if they are "
"known/discovered and available; peers that are stopped or have failed are"
" not included."
msgstr ""

#: ../../source/developapps/connectionoptions.md:151
msgid ""
"<`PluginEventHandlerFunction`> The name of a user-defined event handler. "
"This allows a user to define their own logic for event handling. See how "
"to [define](https://hyperledger.github.io/fabric-sdk-node/master"
"/tutorial-transaction-commit-events.html) a plugin event handler, and "
"examine a [sample handler](https://github.com/hyperledger/fabric-sdk-"
"node/blob/master/test/integration/network-e2e/sample-transaction-event-"
"handler.js)."
msgstr ""

#: ../../source/developapps/connectionoptions.md:157
msgid ""
"A user-defined event handler is only necessary if you have very specific "
"event handling requirements; in general, one of the built-in event "
"strategies will be sufficient. An example of a user-defined event handler"
" might be to wait for more than half the peers in an organization to "
"confirm a transaction has been committed."
msgstr ""

#: ../../source/developapps/connectionoptions.md:163
msgid ""
"If you do specify a user-defined event handler, it does not affect your "
"application logic; it is quite separate from it. The handler is called by"
" the SDK during processing; it decides when to call it, and uses its "
"results to select which peers to use for event notification. The "
"application receives control when the SDK has finished its processing."
msgstr ""

#: ../../source/developapps/connectionoptions.md:169
msgid ""
"If a user-defined event handler is not specified then the default values "
"for `EventStrategies` are used."
msgstr ""

#: ../../source/developapps/connectionoptions.md:173
msgid ""
"`discovery.enabled` is optional and has possible values `true` or "
"`false`. The default is `true`. It determines whether the gateway uses "
"[service discovery](../discovery-overview.html) to augment the network "
"topology specified in the connection profile. See interaction point "
"**6**; peer's gossip information used by the gateway."
msgstr ""

#: ../../source/developapps/connectionoptions.md:179
msgid ""
"This value will be overridden by the `INITIALIIZE-WITH-DISCOVERY` "
"environment variable, which can be set to `true` or `false`."
msgstr ""

#: ../../source/developapps/connectionoptions.md:183
msgid ""
"`discovery.asLocalhost` is optional and has possible values `true` or "
"`false`. The default is `true`. It determines whether IP addresses found "
"during service discovery are translated from the docker network to the "
"local host."
msgstr ""

#: ../../source/developapps/connectionoptions.md:187
msgid ""
"Typically developers will write applications that use docker containers "
"for their network components such as peers, orderers and CAs, but that do"
" not run in docker containers themselves. This is why `true` is the "
"default; in production environments, applications will likely run in "
"docker containers in the same manner as network components and therefore "
"address translation is not required. In this case, applications should "
"either explicitly specify `false` or use the environment variable "
"override."
msgstr ""

#: ../../source/developapps/connectionoptions.md:195
msgid ""
"This value will be overridden by the `DISCOVERY-AS-LOCALHOST` environment"
" variable, which can be set to `true` or `false`."
msgstr ""

#: ../../source/developapps/connectionoptions.md:200
msgid ""
"The following list of considerations is helpful when deciding how to "
"choose connection options."
msgstr ""

#: ../../source/developapps/connectionoptions.md:203
msgid ""
"`eventHandlerOptions.commitTimeout` and `eventHandlerOptions.strategy` "
"work together. For example, `commitTimeout: 100` and `strategy: "
"EventStrategies.MSPID_SCOPE_ANYFORTX` means that the gateway will wait "
"for up to 100 seconds for *any* peer to confirm a transaction has been "
"committed. In contrast, specifying `strategy:  "
"EventStrategies.NETWORK_SCOPE_ALLFORTX` means that the gateway will wait "
"up to 100 seconds for *all* peers in *all* organizations."
msgstr ""

#: ../../source/developapps/connectionoptions.md:212
msgid ""
"The default value of `eventHandlerOptions.strategy: "
"EventStrategies.MSPID_SCOPE_ALLFORTX` will wait for all peers in the "
"application's organization to commit the transaction. This is a good "
"default because applications can be sure that all their peers have an up-"
"to-date copy of the ledger, minimizing concurrency issues <!-- Add a link"
" with more information explaining this topic-->"
msgstr ""

#: ../../source/developapps/connectionoptions.md:219
msgid ""
"However, as the number of peers in an organization grows, it becomes a "
"little unnecessary to wait for all peers, in which case using a pluggable"
" event handler can provide a more efficient strategy. For example the "
"same set of peers could be used to submit transactions and listen for "
"notifications, on the safe assumption that consensus will keep all "
"ledgers synchronized."
msgstr ""

#: ../../source/developapps/connectionoptions.md:226
msgid ""
"Service discovery requires `clientTlsIdentity` to be set. That's because "
"the peers exchanging information with an application need to be confident"
" that they are exchanging information with entities they trust. If "
"`clientTlsIdentity` is not set, then `discovery` will not be obeyed, "
"regardless of whether or not it is set."
msgstr ""

#: ../../source/developapps/connectionoptions.md:233
msgid ""
"Although applications can set connection options when they connect to the"
" gateway, it can be necessary for these options to be overridden by an "
"administrator. That's because options relate to network interactions, "
"which can vary over time. For example, an administrator trying to "
"understand the effect of using service discovery on network performance."
msgstr ""

#: ../../source/developapps/connectionoptions.md:239
msgid ""
"A good approach is to define application overrides in a configuration "
"file which is read by the application when it configures its connection "
"to the gateway."
msgstr ""

#: ../../source/developapps/connectionoptions.md:243
msgid ""
"Because the discovery options `enabled` and `asLocalHost` are most "
"frequently required to be overridden by administrators, the environment "
"variables `INITIALIIZE-WITH-DISCOVERY` and `DISCOVERY-AS-LOCALHOST` are "
"provided for convenience. The administrator should set these in the "
"production runtime environment of the application, which will most likely"
" be a docker container."
msgstr ""

#: ../../source/developapps/connectionprofile.md:1
msgid "# Connection Profile"
msgstr ""

#: ../../source/developapps/connectionprofile.md:3
#: ../../source/developapps/gateway.md:3
#: ../../source/developapps/transactioncontext.md:3
#: ../../source/developapps/wallet.md:3
msgid "**Audience**: Architects, application and smart contract developers"
msgstr ""

#: ../../source/developapps/connectionprofile.md:5
msgid ""
"A connection profile describes a set of components, including peers, "
"orderers and certificate authorities in a Hyperledger Fabric blockchain "
"network. It also contains channel and organization information relating "
"to these components. A connection profile is primarily used by an "
"application to configure a [gateway](./gateway.html) that handles all "
"network interactions, allowing it to focus on business logic. A "
"connection profile is normally created by an administrator who "
"understands the network topology."
msgstr ""

#: ../../source/developapps/connectionprofile.md:15
msgid "[Why connection profiles are important](#scenario)"
msgstr ""

#: ../../source/developapps/connectionprofile.md:16
msgid "[How applications use a connection profile](#usage)"
msgstr ""

#: ../../source/developapps/connectionprofile.md:17
msgid "[How to define a connection profile](#structure)"
msgstr ""

#: ../../source/developapps/connectionprofile.md:21
msgid ""
"A connection profile is used to configure a gateway. Gateways are "
"important for [many reasons](./gateway.html), the primary being to "
"simplify an application's interaction with a network channel."
msgstr ""

#: ../../source/developapps/connectionprofile.md:30
msgid ""
"![profile.scenario](./develop.diagram.30.png) *Two applications, issue "
"and buy,"
msgstr ""

#: ../../source/developapps/connectionprofile.md:26
msgid ""
"use gateways 1&2 configured with connection profiles 1&2. Each profile "
"describes a different subset of MagnetoCorp and DigiBank network "
"components. Each connection profile must contain sufficient information "
"for a gateway to interact with the network on behalf of the issue and buy"
" applications. See the text for a detailed explanation.*"
msgstr ""

#: ../../source/developapps/connectionprofile.md:32
msgid ""
"A connection profile contains a description of a network view, expressed "
"in a technical syntax, which can either be JSON or YAML. In this topic, "
"we use the YAML representation, as it's easier for you to read. Static "
"gateways need more information than dynamic gateways because the latter "
"can use [service discovery](../discovery-overview.html) to dynamically "
"augment the information in a connection profile."
msgstr ""

#: ../../source/developapps/connectionprofile.md:39
msgid ""
"A connection profile should not be an exhaustive description of a network"
" channel; it just needs to contain enough information sufficient for a "
"gateway that's using it. In the network above, connection profile 1 needs"
" to contain at least the endorsing organizations and peers for the "
"`issue` transaction, as well as identifying the peers that will notify "
"the gateway when the transaction has been committed to the ledger."
msgstr ""

#: ../../source/developapps/connectionprofile.md:46
msgid ""
"It's easiest to think of a connection profile as describing a *view* of "
"the network. It could be a comprehensive view, but that's unrealistic for"
" a few reasons:"
msgstr ""

#: ../../source/developapps/connectionprofile.md:50
msgid ""
"Peers, orderers, certificate authorities, channels, and organizations are"
" added and removed according to demand."
msgstr ""

#: ../../source/developapps/connectionprofile.md:53
msgid "Components can start and stop, or fail unexpectedly (e.g. power outage)."
msgstr ""

#: ../../source/developapps/connectionprofile.md:55
msgid ""
"A gateway doesn't need a view of the whole network, only what's necessary"
" to successfully handle transaction submission or event notification for "
"example."
msgstr ""

#: ../../source/developapps/connectionprofile.md:58
msgid ""
"Service Discovery can augment the information in a connection profile. "
"Specifically, dynamic gateways can be configured with minimal Fabric "
"topology information; the rest can be discovered."
msgstr ""

#: ../../source/developapps/connectionprofile.md:62
msgid ""
"A static connection profile is normally created by an administrator who "
"understands the network topology in detail. That's because a static "
"profile can contain quite a lot of information, and an administrator "
"needs to capture this in the corresponding connection profile. In "
"contrast, dynamic profiles minimize the amount of definition required and"
" therefore can be a better choice for developers who want to get going "
"quickly, or administrators who want to create a more responsive gateway. "
"Connection profiles are created in either the YAML or JSON format using "
"an editor of choice."
msgstr ""

#: ../../source/developapps/connectionprofile.md:73
msgid ""
"We'll see how to define a connection profile in a moment; let's first see"
" how it is used by a sample MagnetoCorp `issue` application:"
msgstr ""

#: ../../source/developapps/connectionprofile.md:76
msgid ""
"```javascript const yaml = require('js-yaml'); const { Gateway } = "
"require('fabric-network');"
msgstr ""

#: ../../source/developapps/connectionprofile.md:80
msgid ""
"const connectionProfile = "
"yaml.safeLoad(fs.readFileSync('../gateway/paperNet.yaml', 'utf8'));"
msgstr ""

#: ../../source/developapps/connectionprofile.md:82
msgid "const gateway = new Gateway();"
msgstr ""

#: ../../source/developapps/connectionprofile.md:87
msgid ""
"After loading some required classes, see how the `paperNet.yaml` gateway "
"file is loaded from the file system, converted to a JSON object using the"
" `yaml.safeLoad()` method, and used to configure a gateway using its "
"`connect()` method."
msgstr ""

#: ../../source/developapps/connectionprofile.md:92
msgid ""
"By configuring a gateway with this connection profile, the issue "
"application is providing the gateway with the relevant network topology "
"it should use to process transactions. That's because the connection "
"profile contains sufficient information about the PaperNet channels, "
"organizations, peers, orderers and CAs to ensure transactions can be "
"successfully processed."
msgstr ""

#: ../../source/developapps/connectionprofile.md:98
msgid ""
"It's good practice for a connection profile to define more than one peer "
"for any given organization -- it prevents a single point of failure. This"
" practice also applies to dynamic gateways; to provide more than one "
"starting point for service discovery."
msgstr ""

#: ../../source/developapps/connectionprofile.md:103
msgid ""
"A DigiBank `buy` application would typically configure its gateway with a"
" similar connection profile, but with some important differences. Some "
"elements will be the same, such as the channel; some elements will "
"overlap, such as the endorsing peers. Other elements will be completely "
"different, such as notification peers or certificate authorities for "
"example."
msgstr ""

#: ../../source/developapps/connectionprofile.md:109
msgid ""
"The `connectionOptions` passed to a gateway complement the connection "
"profile. They allow an application to declare how it would like the "
"gateway to use the connection profile. They are interpreted by the SDK to"
" control interaction patterns with network components, for example to "
"select which identity to connect with, or which peers to use for event "
"notifications. Read [about](./connectionoptions.html) the list of "
"available connection options and when to use them."
msgstr ""

#: ../../source/developapps/connectionprofile.md:117
#: ../../source/developapps/transactioncontext.md:89
#: ../../source/developapps/wallet.md:113
msgid "## Structure"
msgstr ""

#: ../../source/developapps/connectionprofile.md:119
msgid ""
"To help you understand the structure of a connection profile, we're going"
" to step through an example for the network shown [above](#scenario). Its"
" connection profile is based on the PaperNet commercial paper sample, and"
" [stored](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-"
"paper/organization/magnetocorp/gateway/networkConnection.yaml) in the "
"GitHub repository. For convenience, we've reproduced it [below](#sample)."
" You will find it helpful to display it in another browser window as you "
"now read about it:"
msgstr ""

#: ../../source/developapps/connectionprofile.md:127
msgid "Line 9: `name: \"papernet.magnetocorp.profile.sample\"`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:129
msgid ""
"This is the name of the connection profile. Try to use DNS style names; "
"they are a very easy way to convey meaning."
msgstr ""

#: ../../source/developapps/connectionprofile.md:133
msgid "Line 16: `x-type: \"hlfv1\"`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:135
msgid ""
"Users can add their own `x-` properties that are \"application-specific\""
" -- just like with HTTP headers. They are provided primarily for future "
"use."
msgstr ""

#: ../../source/developapps/connectionprofile.md:139
msgid ""
"Line 20: `description: \"Sample connection profile for documentation "
"topic\"`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:141
msgid ""
"A short description of the connection profile. Try to make this helpful "
"for the reader who might be seeing this for the first time!"
msgstr ""

#: ../../source/developapps/connectionprofile.md:145
msgid "Line 25: `version: \"1.0\"`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:147
msgid ""
"The schema version for this connection profile.  Currently only version "
"1.0 is supported, and it is not envisioned that this schema will change "
"frequently."
msgstr ""

#: ../../source/developapps/connectionprofile.md:151
msgid "Line 32: `channels:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:153
msgid ""
"This is the first really important line. `channels:` identifies that what"
" follows are *all* the channels that this connection profile describes. "
"However, it is good practice to keep different channels in different "
"connection profiles, especially if they are used independently of each "
"other."
msgstr ""

#: ../../source/developapps/connectionprofile.md:159
msgid "Line 36: `papernet:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:161
msgid ""
"Details of `papernet`, the first channel in this connection profile, will"
" follow."
msgstr ""

#: ../../source/developapps/connectionprofile.md:165
msgid "Line 41: `orderers:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:167
msgid ""
"Details of all the orderers for `papernet` follow. You can see in line 45"
" that the orderer for this channel is `orderer1.magnetocorp.example.com`."
" This is just a logical name; later in the connection profile (lines 134 "
"- 147), there will be details of how to connect to this orderer. Notice "
"that `orderer2.digibank.example.com` is not in this list; it makes sense "
"that applications use their own organization's orderers, rather than "
"those from a different organization."
msgstr ""

#: ../../source/developapps/connectionprofile.md:176
msgid "Line 49: `peers:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:178
msgid "Details of all the peers for `papernet` will follow."
msgstr ""

#: ../../source/developapps/connectionprofile.md:180
msgid ""
"You can see three peers listed from MagnetoCorp: "
"`peer1.magnetocorp.example.com`, `peer2.magnetocorp.example.com` and "
"`peer3.magnetocorp.example.com`. It's not necessary to list all the peers"
" in MagnetoCorp, as has been done here. You can see only one peer listed "
"from DigiBank: `peer9.digibank.example.com`; including this peer starts "
"to imply that the endorsement policy requires MagnetoCorp and DigiBank to"
" endorse transactions, as we'll now confirm. It's good practice to have "
"multiple peers to avoid single points of failure."
msgstr ""

#: ../../source/developapps/connectionprofile.md:189
msgid ""
"Underneath each peer you can see four non-exclusive roles: "
"**endorsingPeer**, **chaincodeQuery**, **ledgerQuery** and "
"**eventSource**. See how `peer1` and `peer2` can perform all roles as "
"they host `papercontract`. Contrast to `peer3`, which can only be used "
"for notifications, or ledger queries that access the blockchain component"
" of the ledger rather than the world state, and hence do not need to have"
" smart contracts installed. Notice how `peer9` should not be used for "
"anything other than endorsement, because those roles are better served by"
" MagnetoCorp peers."
msgstr ""

#: ../../source/developapps/connectionprofile.md:198
msgid ""
"Again, see how the peers are described according to their logical names "
"and their roles. Later in the profile, we'll see the physical information"
" for these peers."
msgstr ""

#: ../../source/developapps/connectionprofile.md:203
msgid "Line 97: `organizations:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:205
msgid ""
"Details of all the organizations will follow, for all channels.  Note "
"that these organizations are for all channels, even though `papernet` is "
"currently the only one listed.  That's because organizations can be in "
"multiple channels, and channels can have multiple organizations. "
"Moreover, some application operations relate to organizations rather than"
" channels. For example, an application can request notification from one "
"or all peers within its organization, or all organizations within the "
"network -- using [connection options](./connectoptions.html).  For this, "
"there needs to be an organization to peer mapping, and this section "
"provides it."
msgstr ""

#: ../../source/developapps/connectionprofile.md:215
msgid "Line 101: `MagnetoCorp:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:217
msgid ""
"All peers that are considered part of MagnetoCorp are listed: `peer1`, "
"`peer2` and `peer3`. Likewise for Certificate Authorities. Again, note "
"the logical name usages, the same as the `channels:` section; physical "
"information will follow later in the profile."
msgstr ""

#: ../../source/developapps/connectionprofile.md:223
msgid "Line 121: `DigiBank:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:225
msgid ""
"Only `peer9` is listed as part of DigiBank, and no Certificate "
"Authorities. That's because these other peers and the DigiBank CA are not"
" relevant for users of this connection profile."
msgstr ""

#: ../../source/developapps/connectionprofile.md:230
msgid "Line 134: `orderers:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:232
msgid ""
"The physical information for orderers is now listed. As this connection "
"profile only mentioned one orderer for `papernet`, you see "
"`orderer1.magnetocorp.example.com` details listed. These include its IP "
"address and port, and gRPC options that can override the defaults used "
"when communicating with the orderer, if necessary. As with `peers:`, for "
"high availability, specifying more than one orderer is a good idea."
msgstr ""

#: ../../source/developapps/connectionprofile.md:240
msgid "Line 152: `peers:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:242
msgid ""
"The physical information for all previous peers is now listed.  This "
"connection profile has three peers for MagnetoCorp: `peer1`, `peer2`, and"
" `peer3`; for DigiBank, a single peer `peer9` has its information listed."
" For each peer, as with orderers, their IP address and port is listed, "
"together with gRPC options that can override the defaults used when "
"communicating with a particular peer, if necessary."
msgstr ""

#: ../../source/developapps/connectionprofile.md:250
msgid "Line 194: `certificateAuthorities:`"
msgstr ""

#: ../../source/developapps/connectionprofile.md:252
msgid ""
"The physical information for certificate authorities is now listed.  The "
"connection profile has a single CA listed for MagnetoCorp, "
"`ca1-magnetocorp`, and its physical information follows. As well as IP "
"details, the registrar information allows this CA to be used for "
"Certificate Signing Requests (CSR). These are used to request new "
"certificates for locally generated public/private key pairs."
msgstr ""

#: ../../source/developapps/connectionprofile.md:259
msgid ""
"Now you've understood a connection profile for MagnetoCorp, you might "
"like to look at a [corresponding](https://github.com/hyperledger/fabric-"
"samples/blob/master/commercial-"
"paper/organization/magnetocorp/gateway/networkConnection.yaml) profile "
"for DigiBank. Locate where the profile is the same as MagnetoCorp's, see "
"where it's similar, and finally where it's different. Think about why "
"these differences make sense for DigiBank applications."
msgstr ""

#: ../../source/developapps/connectionprofile.md:266
msgid ""
"That's everything you need to know about connection profiles. In summary,"
" a connection profile defines sufficient channels, organizations, peers, "
"orderers and certificate authorities for an application to configure a "
"gateway. The gateway allows the application to focus on business logic "
"rather than the details of the network topology."
msgstr ""

#: ../../source/developapps/connectionprofile.md:272
msgid "## Sample"
msgstr ""

#: ../../source/developapps/connectionprofile.md:274
msgid ""
"This file is reproduced inline from the GitHub commercial paper "
"[sample](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-"
"paper/organization/magnetocorp/gateway/networkConnection.yaml)."
msgstr ""

#: ../../source/developapps/connectionprofile.md:277
msgid ""
"``` 1: --- 2: # 3: # [Required]. A connection profile contains "
"information about a set of network 4: # components. It is typically used "
"to configure gateway, allowing applications 5: # interact with a network "
"channel without worrying about the underlying 6: # topology. A connection"
" profile is normally created by an administrator who 7: # understands "
"this topology. 8: # 9: name: \"papernet.magnetocorp.profile.sample\" 10: "
"# 11: # [Optional]. Analogous to HTTP, properties with an \"x-\" prefix "
"are deemed 12: # \"application-specific\", and ignored by the gateway. "
"For example, property 13: # \"x-type\" with value \"hlfv1\" was "
"originally used to identify a connection 14: # profile for Fabric 1.x "
"rather than 0.x. 15: # 16: x-type: \"hlfv1\" 17: # 18: # [Required]. A "
"short description of the connection profile 19: # 20: description: "
"\"Sample connection profile for documentation topic\" 21: # 22: # "
"[Required]. Connection profile schema version. Used by the gateway to 23:"
" # interpret these data. 24: # 25: version: \"1.0\" 26: # 27: # "
"[Optional]. A logical description of each network channel; its peer and "
"28: # orderer names and their roles within the channel. The physical "
"details of 29: # these components (e.g. peer IP addresses) will be "
"specified later in the 30: # profile; we focus first on the logical, and "
"then the physical. 31: # 32: channels: 33:   # 34:   # [Optional]. "
"papernet is the only channel in this connection profile 35:   # 36:   "
"papernet: 37:     # 38:     # [Optional]. Channel orderers for PaperNet. "
"Details of how to connect to 39:     # them is specified later, under the"
" physical \"orderers:\" section 40:     # 41:     orderers: 42:     # 43:"
"     # [Required]. Orderer logical name 44:     # 45:       - "
"orderer1.magnetocorp.example.com 46:     # 47:     # [Optional]. Peers "
"and their roles 48:     # 49:     peers: 50:     # 51:     # [Required]. "
"Peer logical name 52:     # 53:       peer1.magnetocorp.example.com: 54:"
"         # 55:         # [Optional]. Is this an endorsing peer? (It must "
"have chaincode 56:         # installed.) Default: true 57:         # 58:"
"         endorsingPeer: true 59:         # 60:         # [Optional]. Is "
"this peer used for query? (It must have chaincode 61:         # "
"installed.) Default: true 62:         # 63:         chaincodeQuery: true "
"64:         # 65:         # [Optional]. Is this peer used for non-"
"chaincode queries? All peers 66:         # support these types of "
"queries, which include queryBlock(), 67:         # queryTransaction(), "
"etc. Default: true 68:         # 69:         ledgerQuery: true 70:"
"         # 71:         # [Optional]. Is this peer used as an event hub? "
"All peers can produce 72:         # events. Default: true 73:         # "
"74:         eventSource: true 75:       # 76:       "
"peer2.magnetocorp.example.com: 77:         endorsingPeer: true 78:"
"         chaincodeQuery: true 79:         ledgerQuery: true 80:         "
"eventSource: true 81:       # 82:       peer3.magnetocorp.example.com: "
"83:         endorsingPeer: false 84:         chaincodeQuery: false 85:"
"         ledgerQuery: true 86:         eventSource: true 87:       # 88:"
"       peer9.digibank.example.com: 89:         endorsingPeer: true 90:"
"         chaincodeQuery: false 91:         ledgerQuery: false 92:"
"         eventSource: false 93: # 94: # [Required]. List of organizations"
" for all channels. At least one organization 95: # is required. 96: # 97:"
" organizations: 98:    # 99:    # [Required]. Organizational information "
"for MagnetoCorp 100:   # 101:   MagnetoCorp: 102:     # 103:     # "
"[Required]. The MSPID used to identify MagnetoCorp 104:     # 105:     "
"mspid: MagnetoCorpMSP 106:     # 107:     # [Required]. The MagnetoCorp "
"peers 108:     # 109:     peers: 110:       - "
"peer1.magnetocorp.example.com 111:       - peer2.magnetocorp.example.com "
"112:       - peer3.magnetocorp.example.com 113:     # 114:     # "
"[Optional]. Fabric-CA Certificate Authorities. 115:     # 116:     "
"certificateAuthorities: 117:       - ca-magnetocorp 118:   # 119:   # "
"[Optional]. Organizational information for DigiBank 120:   # 121:   "
"DigiBank: 122:     # 123:     # [Required]. The MSPID used to identify "
"DigiBank 124:     # 125:     mspid: DigiBankMSP 126:     # 127:     # "
"[Required]. The DigiBank peers 128:     # 129:     peers: 130:       - "
"peer9.digibank.example.com 131: # 132: # [Optional]. Orderer physical "
"information, by orderer name 133: # 134: orderers: 135:   # 136:   # "
"[Required]. Name of MagnetoCorp orderer 137:   # 138:   "
"orderer1.magnetocorp.example.com: 139:     # 140:     # [Required]. This "
"orderer's IP address 141:     # 142:     url: grpc://localhost:7050 143:"
"     # 144:     # [Optional]. gRPC connection properties used for "
"communication 145:     # 146:     grpcOptions: 147:       ssl-target-"
"name-override: orderer1.magnetocorp.example.com 148: # 149: # [Required]."
" Peer physical information, by peer name. At least one peer is 150: # "
"required. 151: # 152: peers: 153:   # 154:   # [Required]. First "
"MagetoCorp peer physical properties 155:   # 156:   "
"peer1.magnetocorp.example.com: 157:     # 158:     # [Required]. Peer's "
"IP address 159:     # 160:     url: grpc://localhost:7151 161:     # 162:"
"     # [Optional]. gRPC connection properties used for communication 163:"
"     # 164:     grpcOptions: 165:       ssl-target-name-override: "
"peer1.magnetocorp.example.com 166:       request-timeout: 120001 167:   #"
" 168:   # [Optional]. Other MagnetoCorp peers 169:   # 170:   "
"peer2.magnetocorp.example.com: 171:     url: grpc://localhost:7251 172:"
"     grpcOptions: 173:       ssl-target-name-override: "
"peer2.magnetocorp.example.com 174:       request-timeout: 120001 175:   #"
" 176:   peer3.magnetocorp.example.com: 177:     url: "
"grpc://localhost:7351 178:     grpcOptions: 179:       ssl-target-name-"
"override: peer3.magnetocorp.example.com 180:       request-timeout: "
"120001 181:   # 182:   # [Required]. Digibank peer physical properties "
"183:   # 184:   peer9.digibank.example.com: 185:     url: "
"grpc://localhost:7951 186:     grpcOptions: 187:       ssl-target-name-"
"override: peer9.digibank.example.com 188:       request-timeout: 120001 "
"189: # 190: # [Optional]. Fabric-CA Certificate Authority physical "
"information, by name. 191: # This information can be used to (e.g.) "
"enroll new users. Communication is via 192: # REST, hence options relate "
"to HTTP rather than gRPC. 193: # 194: certificateAuthorities: 195:   # "
"196:   # [Required]. MagnetoCorp CA 197:   # 198:   ca1-magnetocorp: 199:"
"     # 200:     # [Required]. CA IP address 201:     # 202:     url: "
"http://localhost:7054 203:     # 204:     # [Optioanl]. HTTP connection "
"properties used for communication 205:     # 206:     httpOptions: 207:"
"       verify: false 208:     # 209:     # [Optional]. Fabric-CA supports"
" Certificate Signing Requests (CSRs). A 210:     # registrar is needed to"
" enroll new users. 211:     # 212:     registrar: 213:       - enrollId: "
"admin 214:         enrollSecret: adminpw 215:     # 216:     # "
"[Optional]. The name of the CA. 217:     # 218:     caName: ca-"
"magnetocorp ```"
msgstr ""

#: ../../source/developapps/contractname.md:1
msgid "# Contract names"
msgstr ""

#: ../../source/developapps/contractname.md:6
msgid ""
"A chaincode is a generic container for deploying code to a Hyperledger "
"Fabric blockchain network. One or more related smart contracts are "
"defined within a chaincode. Every smart contract has a name that uniquely"
" identifies it within a chaincode. Applications access a particular smart"
" contract within a chaincode using its contract name."
msgstr ""

#: ../../source/developapps/contractname.md:12
msgid ""
"In this topic, we're going to cover: * [How a chaincode contains multiple"
" smart contracts](#chaincode) * [How to assign a smart contract "
"name](#name) * [How to use a smart contract from an "
"application](#application) * [The default smart contract](#default-"
"contract)"
msgstr ""

#: ../../source/developapps/contractname.md:18
msgid "## Chaincode"
msgstr ""

#: ../../source/developapps/contractname.md:20
msgid ""
"In the [Developing Applications](./developing_applications.html) topic, "
"we can see how the Fabric SDKs provide high level programming "
"abstractions which help application and smart contract developers to "
"focus on their business problem, rather than the low level details of how"
" to interact with a Fabric network."
msgstr ""

#: ../../source/developapps/contractname.md:25
msgid ""
"Smart contracts are one example of a high level programming abstraction, "
"and it is possible to define smart contracts within in a chaincode "
"container. When a chaincode is installed on your peer and deployed to a "
"channel, all the smart contracts within it are made available to your "
"applications."
msgstr ""

#: ../../source/developapps/contractname.md:30
msgid ""
"![contract.chaincode](./develop.diagram.20.png) *Multiple smart contracts"
" can be defined within a chaincode. Each is uniquely identified by their "
"name within a chaincode.*"
msgstr ""

#: ../../source/developapps/contractname.md:34
msgid ""
"In the diagram [above](#chaincode), chaincode A has three smart contracts"
" defined within it, whereas chaincode B has four smart contracts. See how"
" the chaincode name is used to fully qualify a particular smart contract."
msgstr ""

#: ../../source/developapps/contractname.md:38
msgid ""
"The ledger structure is defined by a set of deployed smart contracts. "
"That's because the ledger contains facts about the business objects of "
"interest to the network (such as commercial paper within PaperNet), and "
"these business objects are moved through their lifecycle (e.g. issue, "
"buy, redeem) by the transaction functions defined within a smart "
"contract."
msgstr ""

#: ../../source/developapps/contractname.md:44
msgid ""
"In most cases, a chaincode will only have one smart contract defined "
"within it. However, it can make sense to keep related smart contracts "
"together in a single chaincode. For example, commercial papers "
"denominated in different currencies might have contracts "
"`EuroPaperContract`, `DollarPaperContract`, `YenPaperContract` which "
"might need to be kept synchronized with each other in the channel to "
"which they are deployed."
msgstr ""

#: ../../source/developapps/contractname.md:51
msgid "## Name"
msgstr ""

#: ../../source/developapps/contractname.md:53
msgid ""
"Each smart contract within a chaincode is uniquely identified by its "
"contract name. A smart contract can explicitly assign this name when the "
"class is constructed, or let the `Contract` class implicitly assign a "
"default name."
msgstr ""

#: ../../source/developapps/contractname.md:57
msgid ""
"Examine the `papercontract.js` chaincode "
"[file](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-"
"paper/organization/magnetocorp/contract/lib/papercontract.js#L31):"
msgstr ""

#: ../../source/developapps/contractname.md:60
msgid "```javascript class CommercialPaperContract extends Contract {"
msgstr ""

#: ../../source/developapps/contractname.md:64
#: ../../source/developapps/smartcontract.md:245
msgid "constructor() {"
msgstr ""

#: ../../source/developapps/contractname.md:64
msgid ""
"// Unique name when multiple contracts per chaincode file "
"super('org.papernet.commercialpaper');"
msgstr ""

#: ../../source/developapps/contractname.md:69
msgid ""
"See how the `CommercialPaperContract` constructor specifies the contract "
"name as `org.papernet.commercialpaper`. The result is that within the "
"`papercontract` chaincode, this smart contract is now associated with the"
" contract name `org.papernet.commercialpaper`."
msgstr ""

#: ../../source/developapps/contractname.md:74
msgid ""
"If an explicit contract name is not specified, then a default name is "
"assigned -- the name of the class.  In our example, the default contract "
"name would be `CommercialPaperContract`."
msgstr ""

#: ../../source/developapps/contractname.md:78
msgid ""
"Choose your names carefully. It's not just that each smart contract must "
"have a unique name; a well-chosen name is illuminating. Specifically, "
"using an explicit DNS-style naming convention is recommended to help "
"organize clear and meaningful names; `org.papernet.commercialpaper` "
"conveys that the PaperNet network has defined a standard commercial paper"
" smart contract."
msgstr ""

#: ../../source/developapps/contractname.md:84
msgid ""
"Contract names are also helpful to disambiguate different smart contract "
"transaction functions with the same name in a given chaincode. This "
"happens when smart contracts are closely related; their transaction names"
" will tend to be the same. We can see that a transaction is uniquely "
"defined within a channel by the combination of its chaincode and smart "
"contract name."
msgstr ""

#: ../../source/developapps/contractname.md:90
msgid ""
"Contract names must be unique within a chaincode file. Some code editors "
"will detect multiple definitions of the same class name before "
"deployment. Regardless the chaincode will return an error if multiple "
"classes with the same contract name are explicitly or implicitly "
"specified."
msgstr ""

#: ../../source/developapps/contractname.md:95
msgid "## Application"
msgstr ""

#: ../../source/developapps/contractname.md:97
msgid ""
"Once a chaincode has been installed on a peer and deployed to a channel, "
"the smart contracts in it are accessible to an application:"
msgstr ""

#: ../../source/developapps/contractname.md:100
#: ../../source/developapps/contractname.md:128
msgid "```javascript const network = await gateway.getNetwork(`papernet`);"
msgstr ""

#: ../../source/developapps/contractname.md:103
msgid ""
"const contract = await network.getContract('papercontract', "
"'org.papernet.commercialpaper');"
msgstr ""

#: ../../source/developapps/contractname.md:105
#: ../../source/developapps/contractname.md:133
msgid ""
"const issueResponse = await contract.submitTransaction('issue', "
"'MagnetoCorp', '00001', '2020-05-31', '2020-11-30', '5000000'); ```"
msgstr ""

#: ../../source/developapps/contractname.md:108
msgid ""
"See how the application accesses the smart contract with the "
"`network.getContract()` method. The `papercontract` chaincode name "
"`org.papernet.commercialpaper` returns a `contract` reference which can "
"be used to submit transactions to issue commercial paper with the "
"`contract.submitTransaction()` API."
msgstr ""

#: ../../source/developapps/contractname.md:114
msgid "## Default contract"
msgstr ""

#: ../../source/developapps/contractname.md:116
msgid ""
"The first smart contract defined in a chaincode is called the *default* "
"smart contract. A default is helpful because a chaincode will usually "
"have one smart contract defined within it; a default allows the "
"application to access those transactions directly -- without specifying a"
" contract name."
msgstr ""

#: ../../source/developapps/contractname.md:121
msgid ""
"![default.contract](./develop.diagram.21.png) *A default smart contract "
"is the first contract defined in a chaincode.*"
msgstr ""

#: ../../source/developapps/contractname.md:124
msgid ""
"In this diagram, `CommercialPaperContract` is the default smart contract."
" Even though we have two smart contracts, the default smart contract "
"makes our [previous](#application) example easier to write:"
msgstr ""

#: ../../source/developapps/contractname.md:131
msgid "const contract = await network.getContract('papercontract');"
msgstr ""

#: ../../source/developapps/contractname.md:136
msgid ""
"This works because the default smart contract in `papercontract` is "
"`CommercialPaperContract` and it has an `issue` transaction. Note that "
"the `issue` transaction in `BondContract` can only be invoked by "
"explicitly addressing it. Likewise, even though the `cancel` transaction "
"is unique, because `BondContract` is *not* the default smart contract, it"
" must also be explicitly addressed."
msgstr ""

#: ../../source/developapps/contractname.md:143
msgid ""
"In most cases, a chaincode will only contain a single smart contract, so "
"careful naming of the chaincode can reduce the need for developers to "
"care about chaincode as a concept. In the example code [above](#default-"
"contract) it feels like `papercontract` is a smart contract."
msgstr ""

#: ../../source/developapps/contractname.md:148
msgid ""
"In summary, contract names are a straightforward mechanism to identify "
"individual smart contracts within a given chaincode. Contract names make "
"it easy for applications to find a particular smart contract and use it "
"to access the ledger."
msgstr ""

#: ../../source/developapps/designelements.rst:2
msgid "Application design elements"
msgstr ""

#: ../../source/developapps/designelements.rst:4
msgid ""
"This section elaborates the key features for client application and smart"
" contract development found in Hyperledger Fabric. A solid understanding "
"of the features will help you design and implement efficient and "
"effective solutions."
msgstr ""

#: ../../source/developapps/developing_applications.rst:2
msgid "Developing Applications"
msgstr ""

#: ../../source/developapps/developing_applications.rst:15
msgid ""
"This topic covers how to develop a client application and smart contract "
"to solve a business problem using Hyperledger Fabric. In a real world "
"**Commercial Paper** scenario, involving multiple organizations, you'll "
"learn about all the concepts and tasks required to accomplish this goal. "
"We assume that the blockchain network is already available."
msgstr ""

#: ../../source/developapps/developing_applications.rst:21
msgid "The topic is designed for multiple audiences:"
msgstr ""

#: ../../source/developapps/developing_applications.rst:23
msgid "Solution and application architect"
msgstr ""

#: ../../source/developapps/developing_applications.rst:24
msgid "Client application developer"
msgstr ""

#: ../../source/developapps/developing_applications.rst:25
msgid "Smart contract developer"
msgstr ""

#: ../../source/developapps/developing_applications.rst:26
msgid "Business professional"
msgstr ""

#: ../../source/developapps/developing_applications.rst:28
msgid ""
"You can choose to read the topic in order, or you can select individual "
"sections as appropriate. Individual topic sections are marked according "
"to reader relevance, so whether you're looking for business or technical "
"information it'll be clear when a topic is for you."
msgstr ""

#: ../../source/developapps/developing_applications.rst:33
msgid ""
"The topic follows a typical software development lifecycle. It starts "
"with business requirements, and then covers all the major technical "
"activities required to develop an application and smart contract to meet "
"these requirements."
msgstr ""

#: ../../source/developapps/developing_applications.rst:38
msgid ""
"If you'd prefer, you can try out the commercial paper scenario "
"immediately, following an abbreviated explanation, by running the "
"commercial paper `tutorial <../tutorial/commercial_paper.html>`_. You can"
" return to this topic when you need fuller explanations of the concepts "
"introduced in the tutorial."
msgstr ""

#: ../../source/developapps/endorsementpolicies.md:1
msgid "# Endorsement policies"
msgstr ""

#: ../../source/developapps/endorsementpolicies.md:5
msgid ""
"Endorsement policies define the smallest set of organizations that are "
"required to endorse a transaction in order for it to be valid. To "
"endorse, an organization's endorsing peer needs to run the smart contract"
" associated with the transaction and sign its outcome. When the ordering "
"service sends the transaction to the committing peers, they will each "
"individually check whether the endorsements in the transaction fulfill "
"the endorsement policy. If this is not the case, the transaction is "
"invalidated and it will have no effect on world state."
msgstr ""

#: ../../source/developapps/endorsementpolicies.md:13
msgid ""
"Endorsement policies work at two different granularities: they can be set"
" for an entire namespace, as well as for individual state keys. They are "
"formulated using basic logic expressions such as `AND` and `OR`. For "
"example, in PaperNet this could be used as follows: the endorsement "
"policy for a paper that has been sold from MagnetoCorp to DigiBank could "
"be set to `AND(MagnetoCorp.peer, DigiBank.peer)`, requiring any changes "
"to this paper to be endorsed by both MagnetoCorp and DigiBank."
msgstr ""

#: ../../source/developapps/gateway.md:1
msgid "# Gateway"
msgstr ""

#: ../../source/developapps/gateway.md:5
msgid ""
"A gateway manages the network interactions on behalf of an application, "
"allowing it to focus on business logic. Applications connect to a gateway"
" and then all subsequent interactions are managed using that gateway's "
"configuration."
msgstr ""

#: ../../source/developapps/gateway.md:11
msgid "[Why gateways are important](#scenario)"
msgstr ""

#: ../../source/developapps/gateway.md:12
msgid "[How applications use a gateway](#connect)"
msgstr ""

#: ../../source/developapps/gateway.md:13
msgid "[How to define a static gateway](#static)"
msgstr ""

#: ../../source/developapps/gateway.md:14
msgid "[How to define a dynamic gateway for service discovery](#dynamic)"
msgstr ""

#: ../../source/developapps/gateway.md:15
msgid "[Using multiple gateways](#multiple-gateways)"
msgstr ""

#: ../../source/developapps/gateway.md:19
msgid ""
"A Hyperledger Fabric network channel can constantly change.  The peer, "
"orderer and CA components, contributed by the different organizations in "
"the network, will come and go. Reasons for this include increased or "
"reduced business demand, and both planned and unplanned outages. A "
"gateway relieves an application of this burden, allowing it to focus on "
"the business problem it is trying to solve."
msgstr ""

#: ../../source/developapps/gateway.md:25
msgid ""
"![gateway.scenario](./develop.diagram.25.png) *A MagnetoCorp and DigiBank"
" applications (issue and buy) delegate their respective network "
"interactions to their gateways. Each gateway understands the network "
"channel topology comprising the multiple peers and orderers of two "
"organizations MagnetoCorp and DigiBank, leaving applications to focus on "
"business logic. Peers can talk to each other both within and across "
"organizations using the gossip protocol.*"
msgstr ""

#: ../../source/developapps/gateway.md:32
msgid "A gateway can be used by an application in two different ways:"
msgstr ""

#: ../../source/developapps/gateway.md:34
msgid ""
"**Static**: The gateway configuration is *completely* defined in a "
"[connection profile](./connectionprofile.html). All the peers, orderers "
"and CAs available to an application are statically defined in the "
"connection profile used to configure the gateway. For peers, this "
"includes their role as an endorsing peer or event notification hub, for "
"example. You can read more about these roles in the connection profile "
"[topic](./connectionprofile.html)."
msgstr ""

#: ../../source/developapps/gateway.md:41
msgid ""
"The SDK will use this static topology, in conjunction with gateway "
"[connection options](./connectionoptions), to manage the transaction "
"submission and notification processes. The connection profile must "
"contain enough of the network topology to allow a gateway to interact "
"with the network on behalf of the application; this includes the network "
"channels, organizations, orderers, peers and their roles."
msgstr ""

#: ../../source/developapps/gateway.md:49
msgid ""
"**Dynamic**: The gateway configuration is minimally defined in a "
"connection profile. Typically, one or two peers from the application's "
"organization are specified, and they use [service discovery"
"](../discovery-overview.html) to discover the available network topology."
" This includes peers, orderers, channels, deployed smart contracts and "
"their endorsement policies. (In production environments, a gateway "
"configuration should specify at least two peers for availability.)"
msgstr ""

#: ../../source/developapps/gateway.md:57
msgid ""
"The SDK will use all of the static and discovered topology information, "
"in conjunction with gateway connection options, to manage the transaction"
" submission and notification processes. As part of this, it will also "
"intelligently use the discovered topology; for example, it will "
"*calculate* the minimum required endorsing peers using the discovered "
"endorsement policy for the smart contract."
msgstr ""

#: ../../source/developapps/gateway.md:64
msgid ""
"You might ask yourself whether a static or dynamic gateway is better? The"
" trade-off is between predictability and responsiveness. Static networks "
"will always behave the same way, as they perceive the network as "
"unchanging. In this sense they are predictable -- they will always use "
"the same peers and orderers if they are available. Dynamic networks are "
"more responsive as they understand how the network changes -- they can "
"use newly added peers and orderers, which brings extra resilience and "
"scalability, at potentially some cost in predictability. In general it's "
"fine to use dynamic networks, and indeed this the default mode for "
"gateways."
msgstr ""

#: ../../source/developapps/gateway.md:74
msgid ""
"Note that the *same* connection profile can be used statically or "
"dynamically. Clearly, if a profile is going to be used statically, it "
"needs to be comprehensive, whereas dynamic usage requires only sparse "
"population."
msgstr ""

#: ../../source/developapps/gateway.md:78
msgid ""
"Both styles of gateway are transparent to the application; the "
"application program design does not change whether static or dynamic "
"gateways are used. This also means that some applications may use service"
" discovery, while others may not. In general using dynamic discovery "
"means less definition and more intelligence by the SDK; it is the "
"default."
msgstr ""

#: ../../source/developapps/gateway.md:84
msgid "## Connect"
msgstr ""

#: ../../source/developapps/gateway.md:86
msgid ""
"When an application connects to a gateway, two options are provided. "
"These are used in subsequent SDK processing:"
msgstr ""

#: ../../source/developapps/gateway.md:89
msgid "```javascript"
msgstr ""

#: ../../source/developapps/gateway.md:90
msgid "await gateway.connect(connectionProfile, connectionOptions);"
msgstr ""

#: ../../source/developapps/gateway.md:93
msgid ""
"**Connection profile**: `connectionProfile` is the gateway configuration "
"that will be used for transaction processing by the SDK, whether "
"statically or dynamically. It can be specified in YAML or JSON, though it"
" must be converted to a JSON object when passed to the gateway:"
msgstr ""

#: ../../source/developapps/gateway.md:98
msgid ""
"```javascript let connectionProfile = "
"yaml.safeLoad(fs.readFileSync('../gateway/paperNet.yaml', 'utf8')); ```"
msgstr ""

#: ../../source/developapps/gateway.md:102
msgid ""
"Read more about [connection profiles](./connectionprofile.html) and how "
"to configure them."
msgstr ""

#: ../../source/developapps/gateway.md:106
msgid ""
"**Connection options**: `connectionOptions` allow an application to "
"declare rather than implement desired transaction processing behaviour. "
"Connection options are interpreted by the SDK to control interaction "
"patterns with network components, for example to select which identity to"
" connect with, or which peers to use for event notifications. These "
"options significantly reduce application complexity without compromising "
"functionality. This is possible because the SDK has implemented much of "
"the low level logic that would otherwise be required by applications; "
"connection options control this logic flow."
msgstr ""

#: ../../source/developapps/gateway.md:116
msgid ""
"Read about the list of available [connection "
"options](./connectionoptions.html) and when to use them."
msgstr ""

#: ../../source/developapps/gateway.md:119
msgid "## Static"
msgstr ""

#: ../../source/developapps/gateway.md:121
msgid ""
"Static gateways define a fixed view of a network. In the MagnetoCorp "
"[scenario](#scenario), a gateway might identify a single peer from "
"MagnetoCorp, a single peer from DigiBank, and a MagentoCorp orderer. "
"Alternatively, a gateway might define *all* peers and orderers from "
"MagnetCorp and DigiBank. In both cases, a gateway must define a view of "
"the network sufficient to get commercial paper transactions endorsed and "
"distributed."
msgstr ""

#: ../../source/developapps/gateway.md:128
msgid ""
"Applications can use a gateway statically by explicitly specifying the "
"connect option `discovery: { enabled:false }` on the `gateway.connect()` "
"API. Alternatively, the environment variable setting "
"`FABRIC_SDK_DISCOVERY=false` will always override the application choice."
msgstr ""

#: ../../source/developapps/gateway.md:133
msgid ""
"Examine the [connection profile](https://github.com/hyperledger/fabric-"
"samples/blob/master/commercial-"
"paper/organization/magnetocorp/gateway/networkConnection.yaml) used by "
"the MagnetoCorp issue application. See how all the peers, orderers and "
"even CAs are specified in this file, including their roles."
msgstr ""

#: ../../source/developapps/gateway.md:138
msgid ""
"It's worth bearing in mind that a static gateway represents a view of a "
"network at a *moment in time*.  As networks change, it may be important "
"to reflect this in a change to the gateway file. Applications will "
"automatically pick up these changes when they re-load the gateway file."
msgstr ""

#: ../../source/developapps/gateway.md:143
msgid "## Dynamic"
msgstr ""

#: ../../source/developapps/gateway.md:145
msgid ""
"Dynamic gateways define a small, fixed *starting point* for a network. In"
" the MagnetoCorp [scenario](#scenario), a dynamic gateway might identify "
"just a single peer from MagnetoCorp; everything else will be discovered! "
"(To provide resiliency, it might be better to define two such bootstrap "
"peers.)"
msgstr ""

#: ../../source/developapps/gateway.md:150
msgid ""
"If [service discovery](../discovery-overview.html) is selected by an "
"application, the topology defined in the gateway file is augmented with "
"that produced by this process. Service discovery starts with the gateway "
"definition, and finds all the connected peers and orderers within the "
"MagnetoCorp organization using the [gossip protocol](../gossip.html). If "
"[anchor peers](../glossary.html#anchor-peer) have been defined for a "
"channel, then service discovery will use the gossip protocol across "
"organizations to discover components within the connected organization. "
"This process will also discover smart contracts installed on peers and "
"their endorsement policies defined at a channel level. As with static "
"gateways, the discovered network must be sufficient to get commercial "
"paper transactions endorsed and distributed."
msgstr ""

#: ../../source/developapps/gateway.md:162
msgid ""
"Dynamic gateways are the default setting for Fabric applications. They "
"can be explicitly specified using the connect option `discovery: { "
"enabled:true }` on the `gateway.connect()` API. Alternatively, the "
"environment variable setting `FABRIC_SDK_DISCOVERY=true` will always "
"override the application choice."
msgstr ""

#: ../../source/developapps/gateway.md:167
msgid ""
"A dynamic gateway represents an up-to-date view of a network. As networks"
" change, service discovery will ensure that the network view is an "
"accurate reflection of the topology visible to the application. "
"Applications will automatically pick up these changes; they do not even "
"need to re-load the gateway file."
msgstr ""

#: ../../source/developapps/gateway.md:173
msgid "## Multiple gateways"
msgstr ""

#: ../../source/developapps/gateway.md:175
msgid ""
"Finally, it is straightforward for an application to define multiple "
"gateways, both for the same or different networks. Moreover, applications"
" can use the name gateway both statically and dynamically."
msgstr ""

#: ../../source/developapps/gateway.md:179
msgid "It can be helpful to have multiple gateways. Here are a few reasons:"
msgstr ""

#: ../../source/developapps/gateway.md:181
msgid "Handling requests on behalf of different users."
msgstr ""

#: ../../source/developapps/gateway.md:183
msgid "Connecting to different networks simultaneously."
msgstr ""

#: ../../source/developapps/gateway.md:185
msgid ""
"Testing a network configuration, by simultaneously comparing its "
"behaviour with an existing configuration."
msgstr ""

#: ../../source/developapps/scenario.md:1
msgid "# The scenario"
msgstr ""

#: ../../source/developapps/scenario.md:6
msgid ""
"In this topic, we're going to describe a business scenario involving six "
"organizations who use PaperNet, a commercial paper network built on "
"Hyperledger Fabric, to issue, buy and redeem commercial paper. We're "
"going to use the scenario to outline requirements for the development of "
"commercial paper applications and smart contracts used by the participant"
" organizations."
msgstr ""

#: ../../source/developapps/scenario.md:12
msgid "## PaperNet network"
msgstr ""

#: ../../source/developapps/scenario.md:14
msgid ""
"PaperNet is a commercial paper network that allows suitably authorized "
"participants to issue, trade, redeem and rate commercial paper."
msgstr ""

#: ../../source/developapps/scenario.md:17
msgid "![develop.systemscontext](./develop.diagram.1.png)"
msgstr ""

#: ../../source/developapps/scenario.md:19
msgid ""
"*The PaperNet commercial paper network. Six organizations currently use "
"PaperNet network to issue, buy, sell, redeem and rate commercial paper. "
"MagentoCorp issues and redeems commercial paper.  DigiBank, BigFund, "
"BrokerHouse and HedgeMatic all trade commercial paper with each other. "
"RateM provides various measures of risk for commercial paper.*"
msgstr ""

#: ../../source/developapps/scenario.md:25
msgid ""
"Let's see how MagnetoCorp uses PaperNet and commercial paper to help its "
"business."
msgstr ""

#: ../../source/developapps/scenario.md:28
msgid "## Introducing the actors"
msgstr ""

#: ../../source/developapps/scenario.md:30
msgid ""
"MagnetoCorp is a well-respected company that makes self-driving electric "
"vehicles. In early April 2020, MagnetoCorp won a large order to "
"manufacture 10,000 Model D cars for Daintree, a new entrant in the "
"personal transport market. Although the order represents a significant "
"win for MagnetoCorp, Daintree will not have to pay for the vehicles until"
" they start to be delivered on November 1, six months after the deal was "
"formally agreed between MagnetoCorp and Daintree."
msgstr ""

#: ../../source/developapps/scenario.md:38
msgid ""
"To manufacture the vehicles, MagnetoCorp will need to hire 1000 workers "
"for at least 6 months. This puts a short term strain on its finances -- "
"it will require an extra 5M USD each month to pay these new employees. "
"**Commercial paper** is designed to help MagnetoCorp overcome its short "
"term financing needs -- to meet payroll every month based on the "
"expectation that it will be cash rich when Daintree starts to pay for its"
" new Model D cars."
msgstr ""

#: ../../source/developapps/scenario.md:45
#, python-format
msgid ""
"At the end of May, MagnetoCorp needs 5M USD to meet payroll for the extra"
" workers it hired on May 1. To do this, it issues a commercial paper with"
" a face value of 5M USD with a maturity date 6 months in the future -- "
"when it expects to see cash flow from Daintree. DigiBank thinks that "
"MagnetoCorp is creditworthy, and therefore doesn't require much of a "
"premium above the central bank base rate of 2%, which would value 4.95M "
"USD today at 5M USD in 6 months time. It therefore purchases the "
"MagnetoCorp 6 month commercial paper for 4.94M USD -- a slight discount "
"compared to the 4.95M USD it is worth. DigiBank fully expects that it "
"will be able to redeem 5M USD from MagnetoCorp in 6 months time, making "
"it a profit of 10K USD for bearing the increased risk associated with "
"this commercial paper. This extra 10K means it receives a 2.4% return on "
"investment -- significantly better than the risk free return of 2%."
msgstr ""

#: ../../source/developapps/scenario.md:58
msgid ""
"At the end of June, when MagnetoCorp issues a new commercial paper for 5M"
" USD to meet June's payroll, it is purchased by BigFund for 4.94M USD.  "
"That's because the commercial conditions are roughly the same in June as "
"they are in May, resulting in BigFund valuing MagnetoCorp commercial "
"paper at the same price that DigiBank did in May."
msgstr ""

#: ../../source/developapps/scenario.md:64
msgid ""
"Each subsequent month, MagnetoCorp can issue new commercial paper to meet"
" its payroll obligations, and these may be purchased by DigiBank, or any "
"other participant in the PaperNet commercial paper network -- BigFund, "
"HedgeMatic or BrokerHouse. These organizations may pay more or less for "
"the commercial paper depending on two factors -- the central bank base "
"rate, and the risk associated with MagnetoCorp. This latter figure "
"depends on a variety of factors such as the production of Model D cars, "
"and the creditworthiness of MagnetoCorp as assessed by RateM, a ratings "
"agency."
msgstr ""

#: ../../source/developapps/scenario.md:73
msgid ""
"The organizations in PaperNet have different roles, MagnetoCorp issues "
"paper, DigiBank, BigFund, HedgeMatic and BrokerHouse trade paper and "
"RateM rates paper. Organizations of the same role, such as DigiBank, "
"Bigfund, HedgeMatic and BrokerHouse are competitors. Organizations of "
"different roles are not necessarily competitors, yet might still have "
"opposing business interest, for example MagentoCorp will desire a high "
"rating for its papers to sell them at a high price, while DigiBank would "
"benefit from a low rating, such that it can buy them at a low price. As "
"can be seen, even a seemingly simple network such as PaperNet can have "
"complex trust relationships. A blockchain can help establish trust among "
"organizations that are competitors or have opposing business interests "
"that might lead to disputes. Fabric in particular has the means to "
"capture even fine-grained trust relationships."
msgstr ""

#: ../../source/developapps/scenario.md:86
msgid ""
"Let's pause the MagnetoCorp story for a moment, and develop the client "
"applications and smart contracts that PaperNet uses to issue, buy, sell "
"and redeem commercial paper as well as capture the trust relationships "
"between the organizations.  We'll come back to the role of the rating "
"agency, RateM, a little later."
msgstr ""

#: ../../source/developapps/smartcontract.md:1
msgid "# Smart Contract Processing"
msgstr ""

#: ../../source/developapps/smartcontract.md:5
msgid ""
"At the heart of a blockchain network is a smart contract. In PaperNet, "
"the code in the commercial paper smart contract defines the valid states "
"for commercial paper, and the transaction logic that transition a paper "
"from one state to another. In this topic, we're going to show you how to "
"implement a real world smart contract that governs the process of "
"issuing, buying and redeeming commercial paper."
msgstr ""

#: ../../source/developapps/smartcontract.md:12
msgid "We're going to cover:"
msgstr ""

#: ../../source/developapps/smartcontract.md:14
msgid "[What is a smart contract and why it's important](#smart-contract)"
msgstr ""

#: ../../source/developapps/smartcontract.md:15
msgid "[How to define a smart contract](#contract-class)"
msgstr ""

#: ../../source/developapps/smartcontract.md:16
msgid "[How to define a transaction](#transaction-definition)"
msgstr ""

#: ../../source/developapps/smartcontract.md:17
msgid "[How to implement a transaction](#transaction-logic)"
msgstr ""

#: ../../source/developapps/smartcontract.md:18
msgid ""
"[How to represent a business object in a smart contract](#representing-"
"an-object)"
msgstr ""

#: ../../source/developapps/smartcontract.md:19
msgid "[How to store and retrieve an object in the ledger](#access-the-ledger)"
msgstr ""

#: ../../source/developapps/smartcontract.md:21
msgid ""
"If you'd like, you can [download the sample](../install.html) and even "
"[run it locally](../tutorial/commercial_paper.html). It is written in "
"JavaScript and Java, but the logic is quite language independent, so "
"you'll easily be able to see what's going on! (The sample will become "
"available for Go as well.)"
msgstr ""

#: ../../source/developapps/smartcontract.md:26
msgid "## Smart Contract"
msgstr ""

#: ../../source/developapps/smartcontract.md:28
msgid ""
"A smart contract defines the different states of a business object and "
"governs the processes that move the object between these different "
"states. Smart contracts are important because they allow architects and "
"smart contract developers to define the key business processes and data "
"that are shared across the different organizations collaborating in a "
"blockchain network."
msgstr ""

#: ../../source/developapps/smartcontract.md:34
msgid ""
"In the PaperNet network, the smart contract is shared by the different "
"network participants, such as MagnetoCorp and DigiBank.  The same version"
" of the smart contract must be used by all applications connected to the "
"network so that they jointly implement the same shared business processes"
" and data."
msgstr ""

#: ../../source/developapps/smartcontract.md:39
msgid "## Implementation Languages"
msgstr ""

#: ../../source/developapps/smartcontract.md:41
msgid ""
"There are two runtimes that are supported, the Java Virtual Machine and "
"Node.js. This gives the opportunity to use one of JavaScript, TypeScript,"
" Java or any other language that can run on one of these supported "
"runtimes."
msgstr ""

#: ../../source/developapps/smartcontract.md:45
msgid ""
"In Java and TypeScript, annotations or decorators are used to provide "
"information about the smart contract and it's structure. This allows for "
"a richer development experience --- for example, author information or "
"return types can be enforced. Within JavaScript, conventions must be "
"followed, therefore, there are limitations around what can be determined "
"automatically."
msgstr ""

#: ../../source/developapps/smartcontract.md:51
msgid "Examples here are given in both JavaScript and Java."
msgstr ""

#: ../../source/developapps/smartcontract.md:53
msgid "## Contract class"
msgstr ""

#: ../../source/developapps/smartcontract.md:55
msgid ""
"A copy of the PaperNet commercial paper smart contract is contained in a "
"single file. View it with your browser, or open it in your favorite "
"editor if you've downloaded it."
msgstr ""

#: ../../source/developapps/smartcontract.md:57
msgid ""
"`papercontract.js` - [JavaScript version](https://github.com/hyperledger"
"/fabric-samples/blob/master/commercial-"
"paper/organization/magnetocorp/contract/lib/papercontract.js)"
msgstr ""

#: ../../source/developapps/smartcontract.md:58
msgid ""
"`CommercialPaperContract.java` - [Java "
"version](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-paper/organization/magnetocorp//contract-"
"java/src/main/java/org/example/CommercialPaperContract.java)"
msgstr ""

#: ../../source/developapps/smartcontract.md:61
msgid ""
"You may notice from the file path that this is MagnetoCorp's copy of the "
"smart contract.  MagnetoCorp and DigiBank must agree on the version of "
"the smart contract that they are going to use. For now, it doesn't matter"
" which organization's copy you use, they are all the same."
msgstr ""

#: ../../source/developapps/smartcontract.md:66
msgid ""
"Spend a few moments looking at the overall structure of the smart "
"contract; notice that it's quite short! Towards the top of the file, "
"you'll see that there's a definition for the commercial paper smart "
"contract: <details open=\"true\"> <summary>JavaScript</summary> "
"```JavaScript class CommercialPaperContract extends Contract {...} ``` "
"</details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:76
msgid ""
"<details> <summary>Java</summary> ```Java @Contract(...) @Default public "
"class CommercialPaperContract implements ContractInterface {...} ``` "
"</details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:86
msgid ""
"The `CommercialPaperContract` class contains the transaction definitions "
"for commercial paper -- **issue**, **buy** and **redeem**. It's these "
"transactions that bring commercial papers into existence and move them "
"through their lifecycle. We'll examine these [transactions](#transaction-"
"definition) soon, but for now notice for JavaScript, that the "
"`CommericalPaperContract` extends the Hyperledger Fabric `Contract` "
"[class](https://hyperledger.github.io/fabric-chaincode-node/master/api"
"/fabric-contract-api.Contract.html)."
msgstr ""

#: ../../source/developapps/smartcontract.md:93
msgid ""
"With Java, the class must be decorated with the `@Contract(...)` "
"annotation. This provides the opportunity to supply additional "
"information about the contract, such as license and author. The "
"`@Default()` annotation indicates that this contract class is the default"
" contract class. Being able to mark a contract class as the default "
"contract class is useful in some smart contracts which have multiple "
"contract classes."
msgstr ""

#: ../../source/developapps/smartcontract.md:98
msgid ""
"If you are using a TypeScript implementation, there are similar "
"`@Contract(...)` annotations that fulfill the same purpose as in Java."
msgstr ""

#: ../../source/developapps/smartcontract.md:100
msgid ""
"For more information on the available annotations, consult the available "
"API documentation: * [API documentation for Java smart "
"contracts](https://hyperledger.github.io/fabric-chaincode-java/) * [API "
"documentation for Node.js smart contracts](https://hyperledger.github.io"
"/fabric-chaincode-node/)"
msgstr ""

#: ../../source/developapps/smartcontract.md:104
msgid ""
"The Fabric contract class is also available for smart contracts written "
"in Go. While we do not discuss the Go contract API in this topic, it uses"
" similar concepts as the API for Java and JavaScript: * [API "
"documentation for Go smart contracts](https://github.com/hyperledger"
"/fabric-contract-api-go)"
msgstr ""

#: ../../source/developapps/smartcontract.md:107
msgid ""
"These classes, annotations, and the `Context` class, were brought into "
"scope earlier:"
msgstr ""

#: ../../source/developapps/smartcontract.md:109
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript const"
" { Contract, Context } = require('fabric-contract-api'); ``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:116
msgid ""
"<details> <summary>Java</summary> ```Java import "
"org.hyperledger.fabric.contract.Context; import "
"org.hyperledger.fabric.contract.ContractInterface; import "
"org.hyperledger.fabric.contract.annotation.Contact; import "
"org.hyperledger.fabric.contract.annotation.Contract; import "
"org.hyperledger.fabric.contract.annotation.Default; import "
"org.hyperledger.fabric.contract.annotation.Info; import "
"org.hyperledger.fabric.contract.annotation.License; import "
"org.hyperledger.fabric.contract.annotation.Transaction; ``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:131
msgid ""
"Our commercial paper contract will use built-in features of these "
"classes, such as automatic method invocation, a [per-transaction "
"context](./transactioncontext.html), [transaction "
"handlers](./transactionhandler.html), and class-shared state."
msgstr ""

#: ../../source/developapps/smartcontract.md:136
msgid ""
"Notice also how the JavaScript class constructor uses its "
"[superclass](https://developer.mozilla.org/en-"
"US/docs/Web/JavaScript/Reference/Operators/super) to initialize itself "
"with an explicit [contract name](./contractname.html):"
msgstr ""

#: ../../source/developapps/smartcontract.md:140
msgid "```JavaScript constructor() {"
msgstr ""

#: ../../source/developapps/smartcontract.md:142
msgid "super('org.papernet.commercialpaper');"
msgstr ""

#: ../../source/developapps/smartcontract.md:146
msgid ""
"With the Java class, the constructor is blank as the explicit contract "
"name can be specified in the `@Contract()` annotation. If it's absent, "
"then the name of the class is used."
msgstr ""

#: ../../source/developapps/smartcontract.md:148
msgid ""
"Most importantly, `org.papernet.commercialpaper` is very descriptive -- "
"this smart contract is the agreed definition of commercial paper for all "
"PaperNet organizations."
msgstr ""

#: ../../source/developapps/smartcontract.md:152
msgid ""
"Usually there will only be one smart contract per file -- contracts tend "
"to have different lifecycles, which makes it sensible to separate them. "
"However, in some cases, multiple smart contracts might provide syntactic "
"help for applications, e.g. `EuroBond`, `DollarBond`, `YenBond`, but "
"essentially provide the same function. In such cases, smart contracts and"
" transactions can be disambiguated."
msgstr ""

#: ../../source/developapps/smartcontract.md:158
msgid "## Transaction definition"
msgstr ""

#: ../../source/developapps/smartcontract.md:160
msgid ""
"Within the class, locate the **issue** method. <details open=\"true\"> "
"<summary>JavaScript</summary> ```JavaScript async issue(ctx, issuer, "
"paperNumber, issueDateTime, maturityDateTime, faceValue) {...} ``` "
"</details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:168
#: ../../source/developapps/smartcontract.md:380
msgid ""
"<details> <summary>Java</summary> ```Java @Transaction public "
"CommercialPaper issue(CommercialPaperContext ctx,"
msgstr ""

#: ../../source/developapps/smartcontract.md:173
msgid ""
"String issuer, String paperNumber, String issueDateTime, String "
"maturityDateTime, int faceValue) {...}"
msgstr ""

#: ../../source/developapps/smartcontract.md:178
#: ../../source/developapps/smartcontract.md:301
#: ../../source/developapps/smartcontract.md:330
#: ../../source/developapps/smartcontract.md:576
msgid "``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:181
msgid ""
"The Java annotation `@Transaction` is used to mark this method as a "
"transaction definition; TypeScript has an equivalent annotation."
msgstr ""

#: ../../source/developapps/smartcontract.md:183
msgid ""
"This function is given control whenever this contract is called to "
"`issue` a commercial paper. Recall how commercial paper 00001 was created"
" with the following transaction:"
msgstr ""

#: ../../source/developapps/smartcontract.md:196
msgid ""
"We've changed the variable names for programming style, but see how these"
" properties map almost directly to the `issue` method variables."
msgstr ""

#: ../../source/developapps/smartcontract.md:199
msgid ""
"The `issue` method is automatically given control by the contract "
"whenever an application makes a request to issue a commercial paper. The "
"transaction property values are made available to the method via the "
"corresponding variables. See how an application submits a transaction "
"using the Hyperledger Fabric SDK in the [application](./application.html)"
" topic, using a sample application program."
msgstr ""

#: ../../source/developapps/smartcontract.md:206
msgid ""
"You might have noticed an extra variable in the **issue** definition -- "
"`ctx`. It's called the [**transaction "
"context**](./transactioncontext.html), and it's always first. By default,"
" it maintains both per-contract and per-transaction information relevant "
"to [transaction logic](#transaction-logic). For example, it would contain"
" MagnetoCorp's specified transaction identifier, a MagnetoCorp issuing "
"user's digital certificate, as well as access to the ledger API."
msgstr ""

#: ../../source/developapps/smartcontract.md:213
msgid ""
"See how the smart contract extends the default transaction context by "
"implementing its own `createContext()` method rather than accepting the "
"default implementation:"
msgstr ""

#: ../../source/developapps/smartcontract.md:217
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript "
"createContext() {"
msgstr ""

#: ../../source/developapps/smartcontract.md:221
msgid "return new CommercialPaperContext()"
msgstr ""

#: ../../source/developapps/smartcontract.md:224
#: ../../source/developapps/smartcontract.md:234
#: ../../source/developapps/smartcontract.md:249
#: ../../source/developapps/smartcontract.md:262
#: ../../source/developapps/smartcontract.md:378
#: ../../source/developapps/smartcontract.md:412
#: ../../source/developapps/smartcontract.md:456
#: ../../source/developapps/smartcontract.md:497
#: ../../source/developapps/smartcontract.md:549
#: ../../source/developapps/smartcontract.md:560
msgid "</details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:226
msgid ""
"<details> <summary>Java</summary> ```Java @Override public Context "
"createContext(ChaincodeStub stub) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:231
msgid "return new CommercialPaperContext(stub);"
msgstr ""

#: ../../source/developapps/smartcontract.md:237
msgid ""
"This extended context adds a custom property `paperList` to the defaults:"
" <details open=\"true\"> <summary>JavaScript</summary> ```JavaScript "
"class CommercialPaperContext extends Context {"
msgstr ""

#: ../../source/developapps/smartcontract.md:244
msgid ""
"super(); // All papers are held in a list of papers this.paperList = new "
"PaperList(this);"
msgstr ""

#: ../../source/developapps/smartcontract.md:251
msgid ""
"<details> <summary>Java</summary> ```Java class CommercialPaperContext "
"extends Context {"
msgstr ""

#: ../../source/developapps/smartcontract.md:256
msgid "public CommercialPaperContext(ChaincodeStub stub) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:256
msgid "super(stub); this.paperList = new PaperList(this);"
msgstr ""

#: ../../source/developapps/smartcontract.md:258
msgid "} public PaperList paperList;"
msgstr ""

#: ../../source/developapps/smartcontract.md:264
msgid ""
"We'll soon see how `ctx.paperList` can be subsequently used to help store"
" and retrieve all PaperNet commercial papers."
msgstr ""

#: ../../source/developapps/smartcontract.md:267
msgid ""
"To solidify your understanding of the structure of a smart contract "
"transaction, locate the **buy** and **redeem** transaction definitions, "
"and see if you can see how they map to their corresponding commercial "
"paper transactions."
msgstr ""

#: ../../source/developapps/smartcontract.md:271
msgid "The **buy** transaction:"
msgstr ""

#: ../../source/developapps/smartcontract.md:283
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript async"
" buy(ctx, issuer, paperNumber, currentOwner, newOwner, price, "
"purchaseTime) {...} ``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:290
#: ../../source/developapps/smartcontract.md:458
msgid ""
"<details> <summary>Java</summary> ```Java @Transaction public "
"CommercialPaper buy(CommercialPaperContext ctx,"
msgstr ""

#: ../../source/developapps/smartcontract.md:295
msgid ""
"String issuer, String paperNumber, String currentOwner, String newOwner, "
"int price, String purchaseDateTime) {...}"
msgstr ""

#: ../../source/developapps/smartcontract.md:304
msgid "The **redeem** transaction:"
msgstr ""

#: ../../source/developapps/smartcontract.md:306
msgid ""
"``` Txn = redeem Issuer = MagnetoCorp Paper = 00001 Redeemer = DigiBank "
"Redeem time = 31 Dec 2020 12:00:00 EST ```"
msgstr ""

#: ../../source/developapps/smartcontract.md:314
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript async"
" redeem(ctx, issuer, paperNumber, redeemingOwner, redeemDateTime) {...} "
"``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:321
msgid ""
"<details> <summary>Java</summary> ```Java @Transaction public "
"CommercialPaper redeem(CommercialPaperContext ctx,"
msgstr ""

#: ../../source/developapps/smartcontract.md:326
msgid ""
"String issuer, String paperNumber, String redeemingOwner, String "
"redeemDateTime) {...}"
msgstr ""

#: ../../source/developapps/smartcontract.md:333
msgid ""
"In both cases, observe the 1:1 correspondence between the commercial "
"paper transaction and the smart contract method definition."
msgstr ""

#: ../../source/developapps/smartcontract.md:336
msgid ""
"All of the JavaScript functions use the `async` and `await` "
"[keywords](https://developer.mozilla.org/en-"
"US/docs/Web/JavaScript/Reference/Statements/async_function) which allow "
"JavaScript functions to be treated as if they were synchronous function "
"calls."
msgstr ""

#: ../../source/developapps/smartcontract.md:340
msgid "## Transaction logic"
msgstr ""

#: ../../source/developapps/smartcontract.md:342
msgid ""
"Now that you've seen how contracts are structured and transactions are "
"defined, let's focus on the logic within the smart contract."
msgstr ""

#: ../../source/developapps/smartcontract.md:345
msgid "Recall the first **issue** transaction:"
msgstr ""

#: ../../source/developapps/smartcontract.md:356
msgid ""
"It results in the **issue** method being passed control: <details "
"open=\"true\"> <summary>JavaScript</summary> ```JavaScript async "
"issue(ctx, issuer, paperNumber, issueDateTime, maturityDateTime, "
"faceValue) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:362
msgid "// create an instance of the paper"
msgstr ""

#: ../../source/developapps/smartcontract.md:363
msgid ""
"let paper = CommercialPaper.createInstance(issuer, paperNumber, "
"issueDateTime, maturityDateTime, faceValue);"
msgstr ""

#: ../../source/developapps/smartcontract.md:365
#: ../../source/developapps/smartcontract.md:397
msgid ""
"// Smart contract, rather than paper, moves paper into ISSUED state "
"paper.setIssued();"
msgstr ""

#: ../../source/developapps/smartcontract.md:368
#: ../../source/developapps/smartcontract.md:400
msgid "// Newly issued paper is owned by the issuer paper.setOwner(issuer);"
msgstr ""

#: ../../source/developapps/smartcontract.md:371
msgid ""
"// Add the paper to the list of all similar commercial papers in the "
"ledger world state await ctx.paperList.addPaper(paper);"
msgstr ""

#: ../../source/developapps/smartcontract.md:374
msgid ""
"// Must return a serialized paper to caller of smart contract return "
"paper.toBuffer();"
msgstr ""

#: ../../source/developapps/smartcontract.md:385
msgid ""
"String issuer, String paperNumber, String issueDateTime, String "
"maturityDateTime, int faceValue) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:391
msgid "System.out.println(ctx);"
msgstr ""

#: ../../source/developapps/smartcontract.md:393
msgid ""
"// create an instance of the paper CommercialPaper paper = "
"CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, "
"maturityDateTime,"
msgstr ""

#: ../../source/developapps/smartcontract.md:395
#: ../../source/developapps/smartcontract.md:575
msgid "faceValue,issuer,\"\");"
msgstr ""

#: ../../source/developapps/smartcontract.md:403
msgid ""
"System.out.println(paper); // Add the paper to the list of all similar "
"commercial papers in the ledger // world state "
"ctx.paperList.addPaper(paper);"
msgstr ""

#: ../../source/developapps/smartcontract.md:408
msgid ""
"// Must return a serialized paper to caller of smart contract return "
"paper;"
msgstr ""

#: ../../source/developapps/smartcontract.md:415
msgid ""
"The logic is simple: take the transaction input variables, create a new "
"commercial paper `paper`, add it to the list of all commercial papers "
"using `paperList`, and return the new commercial paper (serialized as a "
"buffer) as the transaction response."
msgstr ""

#: ../../source/developapps/smartcontract.md:420
msgid ""
"See how `paperList` is retrieved from the transaction context to provide "
"access to the list of commercial papers. `issue()`, `buy()` and "
"`redeem()` continually re-access `ctx.paperList` to keep the list of "
"commercial papers up-to-date."
msgstr ""

#: ../../source/developapps/smartcontract.md:424
msgid ""
"The logic for the **buy** transaction is a little more elaborate: "
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript async"
" buy(ctx, issuer, paperNumber, currentOwner, newOwner, price, "
"purchaseDateTime) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:430
msgid ""
"// Retrieve the current paper using key fields provided let paperKey = "
"CommercialPaper.makeKey([issuer, paperNumber]); let paper = await "
"ctx.paperList.getPaper(paperKey);"
msgstr ""

#: ../../source/developapps/smartcontract.md:434
msgid "// Validate current owner if (paper.getOwner() !== currentOwner) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:436
msgid ""
"throw new Error('Paper ' + issuer + paperNumber + ' is not owned by ' + "
"currentOwner);"
msgstr ""

#: ../../source/developapps/smartcontract.md:439
#: ../../source/developapps/smartcontract.md:479
msgid "// First buy moves state from ISSUED to TRADING if (paper.isIssued()) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:441
#: ../../source/developapps/smartcontract.md:481
msgid "paper.setTrading();"
msgstr ""

#: ../../source/developapps/smartcontract.md:444
#: ../../source/developapps/smartcontract.md:484
msgid "// Check paper is not already REDEEMED if (paper.isTrading()) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:446
#: ../../source/developapps/smartcontract.md:486
msgid "paper.setOwner(newOwner);"
msgstr ""

#: ../../source/developapps/smartcontract.md:447
#: ../../source/developapps/smartcontract.md:488
msgid "} else {"
msgstr ""

#: ../../source/developapps/smartcontract.md:448
msgid ""
"throw new Error('Paper ' + issuer + paperNumber + ' is not trading. "
"Current state = ' +paper.getCurrentState());"
msgstr ""

#: ../../source/developapps/smartcontract.md:451
msgid ""
"// Update the paper await ctx.paperList.updatePaper(paper); return "
"paper.toBuffer();"
msgstr ""

#: ../../source/developapps/smartcontract.md:463
msgid ""
"String issuer, String paperNumber, String currentOwner, String newOwner, "
"int price, String purchaseDateTime) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:470
msgid ""
"// Retrieve the current paper using key fields provided String paperKey ="
" State.makeKey(new String[] { paperNumber }); CommercialPaper paper = "
"ctx.paperList.getPaper(paperKey);"
msgstr ""

#: ../../source/developapps/smartcontract.md:474
msgid "// Validate current owner if (!paper.getOwner().equals(currentOwner)) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:476
msgid ""
"throw new RuntimeException(\"Paper \" + issuer + paperNumber + \" is not "
"owned by \" + currentOwner);"
msgstr ""

#: ../../source/developapps/smartcontract.md:488
msgid "throw new RuntimeException("
msgstr ""

#: ../../source/developapps/smartcontract.md:489
msgid ""
"\"Paper \" + issuer + paperNumber + \" is not trading. Current state = \""
" + paper.getState());"
msgstr ""

#: ../../source/developapps/smartcontract.md:492
msgid "// Update the paper ctx.paperList.updatePaper(paper); return paper;"
msgstr ""

#: ../../source/developapps/smartcontract.md:499
msgid ""
"See how the transaction checks `currentOwner` and that `paper` is "
"`TRADING` before changing the owner with `paper.setOwner(newOwner)`. The "
"basic flow is simple though -- check some pre-conditions, set the new "
"owner, update the commercial paper on the ledger, and return the updated "
"commercial paper (serialized as a buffer) as the transaction response."
msgstr ""

#: ../../source/developapps/smartcontract.md:505
msgid ""
"Why don't you see if you can understand the logic for the **redeem** "
"transaction?"
msgstr ""

#: ../../source/developapps/smartcontract.md:508
msgid "## Representing an object"
msgstr ""

#: ../../source/developapps/smartcontract.md:510
msgid ""
"We've seen how to define and implement the **issue**, **buy** and "
"**redeem** transactions using the `CommercialPaper` and `PaperList` "
"classes. Let's end this topic by seeing how these classes work."
msgstr ""

#: ../../source/developapps/smartcontract.md:514
msgid "Locate the `CommercialPaper` class:"
msgstr ""

#: ../../source/developapps/smartcontract.md:516
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> In the [paper.js "
"file](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-paper/organization/magnetocorp/contract/lib/paper.js):"
msgstr ""

#: ../../source/developapps/smartcontract.md:521
msgid "```JavaScript class CommercialPaper extends State {...} ``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:526
msgid ""
"<details> <summary>Java</summary> In the [CommercialPaper.java "
"file](https://github.com/hyperledger/fabric-samples/blob/release-1.4"
"/commercial-paper/organization/magnetocorp/contract-"
"java/src/main/java/org/example/CommercialPaper.java):"
msgstr ""

#: ../../source/developapps/smartcontract.md:531
msgid ""
"```Java @DataType() public class CommercialPaper extends State {...} ``` "
"</details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:538
msgid ""
"This class contains the in-memory representation of a commercial paper "
"state. See how the `createInstance` method initializes a new commercial "
"paper with the provided parameters:"
msgstr ""

#: ../../source/developapps/smartcontract.md:542
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript "
"static createInstance(issuer, paperNumber, issueDateTime, "
"maturityDateTime, faceValue) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:546
msgid ""
"return new CommercialPaper({ issuer, paperNumber, issueDateTime, "
"maturityDateTime, faceValue });"
msgstr ""

#: ../../source/developapps/smartcontract.md:551
msgid ""
"<details> <summary>Java</summary> ```Java public static CommercialPaper "
"createInstance(String issuer, String paperNumber, String issueDateTime,"
msgstr ""

#: ../../source/developapps/smartcontract.md:555
msgid "String maturityDateTime, int faceValue, String owner, String state) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:556
msgid ""
"return new "
"CommercialPaper().setIssuer(issuer).setPaperNumber(paperNumber).setMaturityDateTime(maturityDateTime)"
msgstr ""

#: ../../source/developapps/smartcontract.md:557
msgid ".setFaceValue(faceValue).setKey().setIssueDateTime(issueDateTime).setOwner(owner).setState(state);"
msgstr ""

#: ../../source/developapps/smartcontract.md:562
msgid "Recall how this class was used by the **issue** transaction:"
msgstr ""

#: ../../source/developapps/smartcontract.md:564
msgid ""
"<details open=\"true\"> <summary>JavaScript</summary> ```JavaScript let "
"paper = CommercialPaper.createInstance(issuer, paperNumber, "
"issueDateTime, maturityDateTime, faceValue); ``` </details>"
msgstr ""

#: ../../source/developapps/smartcontract.md:571
msgid ""
"<details> <summary>Java</summary> ```Java CommercialPaper paper = "
"CommercialPaper.createInstance(issuer, paperNumber, issueDateTime, "
"maturityDateTime,"
msgstr ""

#: ../../source/developapps/smartcontract.md:579
msgid ""
"See how every time the issue transaction is called, a new in-memory "
"instance of a commercial paper is created containing the transaction "
"data."
msgstr ""

#: ../../source/developapps/smartcontract.md:582
msgid "A few important points to note:"
msgstr ""

#: ../../source/developapps/smartcontract.md:584
msgid ""
"This is an in-memory representation; we'll see [later](#accessing-the-"
"ledger) how it appears on the ledger."
msgstr ""

#: ../../source/developapps/smartcontract.md:588
msgid ""
"The `CommercialPaper` class extends the `State` class. `State` is an "
"application-defined class which creates a common abstraction for a state."
" All states have a business object class which they represent, a "
"composite key, can be serialized and de-serialized, and so on.  `State` "
"helps our code be more legible when we are storing more than one business"
" object type on the ledger. Examine the `State` class in the `state.js` "
"[file](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-paper/organization/magnetocorp/contract/ledger-api/state.js)."
msgstr ""

#: ../../source/developapps/smartcontract.md:597
msgid ""
"A paper computes its own key when it is created -- this key will be used "
"when the ledger is accessed. The key is formed from a combination of "
"`issuer` and `paperNumber`."
msgstr ""

#: ../../source/developapps/smartcontract.md:601
msgid "```JavaScript constructor(obj) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:603
msgid ""
"super(CommercialPaper.getClass(), [obj.issuer, obj.paperNumber]); "
"Object.assign(this, obj);"
msgstr ""

#: ../../source/developapps/smartcontract.md:609
msgid ""
"A paper is moved to the `ISSUED` state by the transaction, not by the "
"paper class. That's because it's the smart contract that governs the "
"lifecycle state of the paper. For example, an `import` transaction might "
"create a new set of papers immediately in the `TRADING` state."
msgstr ""

#: ../../source/developapps/smartcontract.md:614
msgid "The rest of the `CommercialPaper` class contains simple helper methods:"
msgstr ""

#: ../../source/developapps/smartcontract.md:616
msgid "```JavaScript getOwner() {"
msgstr ""

#: ../../source/developapps/smartcontract.md:618
msgid "return this.owner;"
msgstr ""

#: ../../source/developapps/smartcontract.md:622
msgid ""
"Recall how methods like this were used by the smart contract to move the "
"commercial paper through its lifecycle. For example, in the **redeem** "
"transaction we saw:"
msgstr ""

#: ../../source/developapps/smartcontract.md:626
msgid "```JavaScript if (paper.getOwner() === redeemingOwner) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:628
msgid "paper.setOwner(paper.getIssuer()); paper.setRedeemed();"
msgstr ""

#: ../../source/developapps/smartcontract.md:633
msgid "## Access the ledger"
msgstr ""

#: ../../source/developapps/smartcontract.md:635
msgid ""
"Now locate the `PaperList` class in the `paperlist.js` "
"[file](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-paper/organization/magnetocorp/contract/lib/paperlist.js):"
msgstr ""

#: ../../source/developapps/smartcontract.md:638
msgid "```JavaScript class PaperList extends StateList { ```"
msgstr ""

#: ../../source/developapps/smartcontract.md:642
msgid ""
"This utility class is used to manage all PaperNet commercial papers in "
"Hyperledger Fabric state database. The PaperList data structures are "
"described in more detail in the [architecture "
"topic](./architecture.html)."
msgstr ""

#: ../../source/developapps/smartcontract.md:646
msgid ""
"Like the `CommercialPaper` class, this class extends an application-"
"defined `StateList` class which creates a common abstraction for a list "
"of states -- in this case, all the commercial papers in PaperNet."
msgstr ""

#: ../../source/developapps/smartcontract.md:650
msgid ""
"The `addPaper()` method is a simple veneer over the "
"`StateList.addState()` method:"
msgstr ""

#: ../../source/developapps/smartcontract.md:653
msgid "```JavaScript async addPaper(paper) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:655
msgid "return this.addState(paper);"
msgstr ""

#: ../../source/developapps/smartcontract.md:659
msgid ""
"You can see in the `StateList.js` [file](https://github.com/hyperledger"
"/fabric-samples/blob/master/commercial-"
"paper/organization/magnetocorp/contract/ledger-api/statelist.js) how the "
"`StateList` class uses the Fabric API `putState()` to write the "
"commercial paper as state data in the ledger:"
msgstr ""

#: ../../source/developapps/smartcontract.md:664
msgid "```JavaScript async addState(state) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:666
#: ../../source/developapps/smartcontract.md:704
msgid ""
"let key = this.ctx.stub.createCompositeKey(this.name, "
"state.getSplitKey()); let data = State.serialize(state); await "
"this.ctx.stub.putState(key, data);"
msgstr ""

#: ../../source/developapps/smartcontract.md:672
msgid ""
"Every piece of state data in a ledger requires these two fundamental "
"elements:"
msgstr ""

#: ../../source/developapps/smartcontract.md:674
msgid ""
"**Key**: `key` is formed with `createCompositeKey()` using a fixed name "
"and the key of `state`. The name was assigned when the `PaperList` object"
" was constructed, and `state.getSplitKey()` determines each state's "
"unique key."
msgstr ""

#: ../../source/developapps/smartcontract.md:679
msgid ""
"**Data**: `data` is simply the serialized form of the commercial paper "
"state, created using the `State.serialize()` utility method. The `State` "
"class serializes and deserializes data using JSON, and the State's "
"business object class as required, in our case `CommercialPaper`, again "
"set when the `PaperList` object was constructed."
msgstr ""

#: ../../source/developapps/smartcontract.md:686
msgid ""
"Notice how a `StateList` doesn't store anything about an individual state"
" or the total list of states -- it delegates all of that to the Fabric "
"state database. This is an important design pattern -- it reduces the "
"opportunity for [ledger MVCC collisions](../readwrite.html) in "
"Hyperledger Fabric."
msgstr ""

#: ../../source/developapps/smartcontract.md:691
msgid ""
"The StateList `getState()` and `updateState()` methods work in similar "
"ways:"
msgstr ""

#: ../../source/developapps/smartcontract.md:693
msgid "```JavaScript async getState(key) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:695
msgid ""
"let ledgerKey = this.ctx.stub.createCompositeKey(this.name, "
"State.splitKey(key)); let data = await this.ctx.stub.getState(ledgerKey);"
" let state = State.deserialize(data, this.supportedClasses); return "
"state;"
msgstr ""

#: ../../source/developapps/smartcontract.md:702
msgid "```JavaScript async updateState(state) {"
msgstr ""

#: ../../source/developapps/smartcontract.md:710
msgid ""
"See how they use the Fabric APIs `putState()`, `getState()` and "
"`createCompositeKey()` to access the ledger. We'll expand this smart "
"contract later to list all commercial papers in paperNet -- what might "
"the method look like to implement this ledger retrieval?"
msgstr ""

#: ../../source/developapps/smartcontract.md:715
msgid ""
"That's it! In this topic you've understood how to implement the smart "
"contract for PaperNet.  You can move to the next sub topic to see how an "
"application calls the smart contract using the Fabric SDK."
msgstr ""

#: ../../source/developapps/transactioncontext.md:1
msgid "# Transaction context"
msgstr ""

#: ../../source/developapps/transactioncontext.md:5
msgid ""
"A transaction context performs two functions. Firstly, it allows a "
"developer to define and maintain user variables across transaction "
"invocations within a smart contract. Secondly, it provides access to a "
"wide range of Fabric APIs that allow smart contract developers to perform"
" operations relating to detailed transaction processing. These range from"
" querying or updating the ledger, both the immutable blockchain and the "
"modifiable world state, to retrieving the transaction-submitting "
"application's digital identity."
msgstr ""

#: ../../source/developapps/transactioncontext.md:13
msgid ""
"A transaction context is created when a smart contract is deployed to a "
"channel and made available to every subsequent transaction invocation. A "
"transaction context helps smart contract developers write programs that "
"are powerful, efficient and easy to reason about."
msgstr ""

#: ../../source/developapps/transactioncontext.md:18
msgid "[Why a transaction context is important](#scenario)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:19
msgid "[How to use a transaction context](#programming)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:20
msgid "[What's in a transaction context](#structure)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:21
msgid "[Using a context `stub`](#stub)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:22
msgid "[Using a context `clientIdentity`](#clientIdentity)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:26
msgid ""
"In the commercial paper sample, "
"[papercontract](https://github.com/hyperledger/fabric-samples/blob/master"
"/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js)"
" initially defines the name of the list of commercial papers for which "
"it's responsible. Each transaction subsequently refers to this list; the "
"issue transaction adds new papers to it, the buy transaction changes its "
"owner, and the redeem transaction marks it as complete. This is a common "
"pattern; when writing a smart contract it's often helpful to initialize "
"and recall particular variables in sequential transactions."
msgstr ""

#: ../../source/developapps/transactioncontext.md:35
msgid ""
"![transaction.scenario](./develop.diagram.40.png) *A smart contract "
"transaction context allows smart contracts to define and maintain user "
"variables across transaction invocations. Refer to the text for a "
"detailed explanation.*"
msgstr ""

#: ../../source/developapps/transactioncontext.md:39
msgid "## Programming"
msgstr ""

#: ../../source/developapps/transactioncontext.md:41
msgid ""
"When a smart contract is constructed, a developer can optionally override"
" the built-in `Context` class `createContext` method to create a custom "
"context:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:44
msgid "```JavaScript createContext() {"
msgstr ""

#: ../../source/developapps/transactioncontext.md:46
msgid "new CommercialPaperContext();"
msgstr ""

#: ../../source/developapps/transactioncontext.md:50
msgid ""
"In our example, the `CommercialPaperContext` is specialized for "
"`CommercialPaperContract`. See how the custom context, addressed through "
"`this`, adds the specific variable `PaperList` to itself:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:54
msgid "```JavaScript CommercialPaperContext extends Context {"
msgstr ""

#: ../../source/developapps/transactioncontext.md:56
msgid "constructor () {"
msgstr ""

#: ../../source/developapps/transactioncontext.md:57
msgid "this.paperList = new PaperList(this);"
msgstr ""

#: ../../source/developapps/transactioncontext.md:62
msgid ""
"When the createContext() method returns at point **(1)** in the diagram "
"[above](#scenario), a custom context `ctx` has been created which "
"contains `paperList` as one of its variables."
msgstr ""

#: ../../source/developapps/transactioncontext.md:66
msgid ""
"Subsequently, whenever a smart contract transaction such as issue, buy or"
" redeem is called, this context will be passed to it. See how at points "
"**(2)**, **(3)** and **(4)** the same commercial paper context is passed "
"into the transaction method using the `ctx` variable."
msgstr ""

#: ../../source/developapps/transactioncontext.md:71
msgid "See how the context is then used at point **(5)**:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:73
msgid "```JavaScript ctx.paperList.addPaper(...); ctx.stub.putState(...); ```"
msgstr ""

#: ../../source/developapps/transactioncontext.md:78
msgid ""
"Notice how `paperList` created in `CommercialPaperContext` is available "
"to the issue transaction. See how `paperList` is similarly used by the "
"**redeem** and **buy** transactions; `ctx` makes the smart contracts "
"efficient and easy to reason about."
msgstr ""

#: ../../source/developapps/transactioncontext.md:83
msgid ""
"You can also see that there's another element in the context -- "
"`ctx.stub` -- which was not explicitly added by `CommercialPaperContext`."
" That's because `stub` and other variables are part of the built-in "
"context. Let's now examine the structure of this built-in context, these "
"implicit variables and how to use them."
msgstr ""

#: ../../source/developapps/transactioncontext.md:91
msgid ""
"As we've seen from the [example](#programming), a transaction context can"
" contain any number of user variables such as `paperList`."
msgstr ""

#: ../../source/developapps/transactioncontext.md:94
msgid ""
"The transaction context also contains two built-in elements that provide "
"access to a wide range of Fabric functionality ranging from the client "
"application that submitted the transaction to ledger access."
msgstr ""

#: ../../source/developapps/transactioncontext.md:98
msgid ""
"`ctx.stub` is used to access APIs that provide a broad range of "
"transaction processing operations from `putState()` and `getState()` to "
"access the ledger, to `getTxID()` to retrieve the current transaction ID."
msgstr ""

#: ../../source/developapps/transactioncontext.md:102
msgid ""
"`ctx.clientIdentity` is used to get information about the identity of the"
" user who submitted the transaction."
msgstr ""

#: ../../source/developapps/transactioncontext.md:105
msgid ""
"We'll use the following diagram to show you what a smart contract can do "
"using the `stub` and `clientIdentity` using the APIs available to it:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:108
msgid ""
"![context.apis](./develop.diagram.41.png) *A smart contract can access a "
"range of functionality in a smart contract via the transaction context "
"`stub` and `clientIdentity`. Refer to the text for a detailed "
"explanation.*"
msgstr ""

#: ../../source/developapps/transactioncontext.md:112
msgid "## Stub"
msgstr ""

#: ../../source/developapps/transactioncontext.md:114
msgid "The APIs in the stub fall into the following categories:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:116
msgid ""
"**World state data APIs**. See interaction point **(1)**. These APIs "
"enable smart contracts to get, put and delete state corresponding to "
"individual objects from the world state, using their key:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:120
msgid ""
"[getState()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getState__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:121
msgid ""
"[putState()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#putState__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:122
msgid ""
"[deleteState()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#deleteState__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:124
msgid ""
"<br> These basic APIs are complemented by query APIs which enable "
"contracts to retrieve a set of states, rather than an individual state. "
"See interaction point **(2)**. The set is either defined by a range of "
"key values, using full or partial keys, or a query according to values in"
" the underlying world state [database](../ledger/ledger.html#world-state-"
"database-options).  For large queries, the result sets can be paginated "
"to reduce storage requirements:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:131
msgid ""
"[getStateByRange()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getStateByRange__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:132
msgid ""
"[getStateByRangeWithPagination()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getStateByRangeWithPagination__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:133
msgid ""
"[getStateByPartialCompositeKey()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getStateByPartialCompositeKey__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:134
msgid ""
"[getStateByPartialCompositeKeyWithPagination()](https://hyperledger.github.io"
"/fabric-chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getStateByPartialCompositeKeyWithPagination__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:135
msgid ""
"[getQueryResult()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getQueryResult__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:136
msgid ""
"[getQueryResultWithPagination()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getQueryResultWithPagination__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:138
msgid ""
"**Private data APIs**. See interaction point **(3)**. These APIs enable "
"smart contracts to interact with a private data collection. They are "
"analogous to the APIs for world state interactions, but for private data."
" There are APIs to get, put and delete a private data state by its key:"
msgstr ""

#: ../../source/developapps/transactioncontext.md:143
msgid ""
"[getPrivateData()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getPrivateData__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:144
msgid ""
"[putPrivateData()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#putPrivateData__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:145
msgid ""
"[deletePrivateData()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#deletePrivateData__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:147
msgid ""
"<br> This set is complemented by set of APIs to query private data "
"**(4)**. These APIs allow smart contracts to retrieve a set of states "
"from a private data collection, according to a range of key values, "
"either full or partial keys, or a query according to values in the "
"underlying world state [database](../ledger/ledger.html#world-state-"
"database-options). There are currently no pagination APIs for private "
"data collections."
msgstr ""

#: ../../source/developapps/transactioncontext.md:154
msgid ""
"[getPrivateDataByRange()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-"
"shim.ChaincodeStub.html#getPrivateDataByRange__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:155
msgid ""
"[getPrivateDataByPartialCompositeKey()](https://hyperledger.github.io"
"/fabric-chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getPrivateDataByPartialCompositeKey__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:156
msgid ""
"[getPrivateDataQueryResult()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getPrivateDataQueryResult__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:158
msgid ""
"**Transaction APIs**. See interaction point **(5)**. These APIs are used "
"by a smart contract to retrieve details about the current transaction "
"proposal being processed by the smart contract. This includes the "
"transaction identifier and the time when the transaction proposal was "
"created."
msgstr ""

#: ../../source/developapps/transactioncontext.md:163
msgid ""
"[getTxID()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getTxID__anchor) returns "
"the identifier of the current transaction proposal **(5)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:165
msgid ""
"[getTxTimestamp()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getTxTimestamp__anchor) "
"returns the timestamp when the current transaction proposal was created "
"by the application **(5)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:168
msgid ""
"[getCreator()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getCreator__anchor) "
"returns the raw identity (X.509 or otherwise) of the creator of "
"transaction proposal. If this is an X.509 certificate then it is often "
"more appropriate to use [`ctx.ClientIdentity`](#clientidentity)."
msgstr ""

#: ../../source/developapps/transactioncontext.md:172
msgid ""
"[getSignedProposal()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getSignedProposal__anchor)"
" returns a signed copy of the current transaction proposal being "
"processed by the smart contract."
msgstr ""

#: ../../source/developapps/transactioncontext.md:175
msgid ""
"[getBinding()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getBinding__anchor) is "
"used to prevent transactions being maliciously or accidentally replayed "
"using a nonce. (For practical purposes, a nonce is a random number "
"generated by the client application and incorporated in a cryptographic "
"hash.) For example, this API could be used by a smart contract at **(1)**"
" to detect a replay of the transaction **(5)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:181
msgid ""
"[getTransient()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getTransient__anchor) "
"allows a smart contract to access the transient data an application "
"passes to a smart contract. See interaction points **(9)** and **(10)**. "
"Transient data is private to the application-smart contract interaction. "
"It is not recorded on the ledger and is often used in conjunction with "
"private data collections **(3)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:188
#: ../../source/developapps/transactioncontext.md:209
#: ../../source/developapps/transactioncontext.md:220
msgid "<br>"
msgstr ""

#: ../../source/developapps/transactioncontext.md:190
msgid ""
"**Key APIs** are used by smart contracts to manipulate state key in the "
"world state or a private data collection. See interaction points **2** "
"and **4**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:193
msgid ""
"The simplest of these APIs allows smart contracts to form and split "
"composite keys from their individual components. Slightly more advanced "
"are the `ValidationParameter()` APIs which get and set the state based "
"endorsement policies for world state **(2)** and private data **(4)**. "
"Finally, `getHistoryForKey()` retrieves the history for a state by "
"returning the set of stored values, including the transaction identifiers"
" that performed the state update, allowing the transactions to be read "
"from the blockchain **(10)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:201
msgid ""
"[createCompositeKey()](https://hyperledger.github.io/fabric-chaincode-"
"node/{BRACNH}/api/fabric-"
"shim.ChaincodeStub.html#createCompositeKey__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:202
msgid ""
"[splitCompositeKey()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#splitCompositeKey__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:203
msgid ""
"[setStateValidationParameter()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#setStateValidationParameter__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:204
msgid ""
"[getStateValidationParameter()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getStateValidationParameter__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:205
msgid ""
"[getPrivateDataValidationParameter()](https://hyperledger.github.io"
"/fabric-chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getPrivateDataValidationParameter__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:206
msgid ""
"[setPrivateDataValidationParameter()](https://hyperledger.github.io"
"/fabric-chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#setPrivateDataValidationParameter__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:207
msgid ""
"[getHistoryForKey()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getHistoryForKey__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:211
msgid "**Event APIs** are used to manage event processing in a smart contract."
msgstr ""

#: ../../source/developapps/transactioncontext.md:213
msgid ""
"[setEvent()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#setEvent__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:215
msgid ""
"Smart contracts use this API to add user events to a transaction "
"response. See interaction point **(5)**. These events are ultimately "
"recorded on the blockchain and sent to listening applications at "
"interaction point **(11)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:222
msgid ""
"**Utility APIs** are a collection of useful APIs that don't easily fit in"
" a pre-defined category, so we've grouped them together! They include "
"retrieving the current channel name and passing control to a different "
"chaincode on the same peer."
msgstr ""

#: ../../source/developapps/transactioncontext.md:227
msgid ""
"[getChannelID()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getChannelID__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:229
msgid ""
"See interaction point **(13)**.  A smart contract running on any peer can"
" use this API to determined on which channel the application invoked the "
"smart contract."
msgstr ""

#: ../../source/developapps/transactioncontext.md:233
msgid ""
"[invokeChaincode()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:235
msgid ""
"See interaction point **(14)**.  Peer3 owned by MagnetoCorp has multiple "
"smart contracts installed on it.  These smart contracts are able to call "
"each other using this API. The smart contracts must be collocated; it is "
"not possible to call a smart contract on a different peer."
msgstr ""

#: ../../source/developapps/transactioncontext.md:240
msgid "<br> Some of these utility APIs are only used if you're using low-level"
msgstr ""

#: ../../source/developapps/transactioncontext.md:241
msgid ""
"chaincode, rather than smart contracts. These APIs are primarily for the "
"detailed manipulation of chaincode input; the smart contract `Contract` "
"class does all of this parameter marshalling automatically for "
"developers."
msgstr ""

#: ../../source/developapps/transactioncontext.md:245
msgid ""
"[getFunctionAndParameters()](https://hyperledger.github.io/fabric-"
"chaincode-node/master/api/fabric-"
"shim.ChaincodeStub.html#getFunctionAndParameters__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:246
msgid ""
"[getStringArgs()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getStringArgs__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:247
msgid ""
"[getArgs()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ChaincodeStub.html#getArgs__anchor)"
msgstr ""

#: ../../source/developapps/transactioncontext.md:249
msgid "## ClientIdentity"
msgstr ""

#: ../../source/developapps/transactioncontext.md:251
msgid ""
"In most cases, the application submitting a transaction will be using an "
"X.509 certificate. In the [example](#structure), an X.509 certificate "
"**(6)** issued by `CA1` **(7)** is being used by `Isabella` **(8)** in "
"her application to sign the proposal in transaction `t6` **(5)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:256
msgid ""
"`ClientIdentity` takes the information returned by `getCreator()` and "
"puts a set of X.509 utility APIs on top of it to make it easier to use "
"for this common use case."
msgstr ""

#: ../../source/developapps/transactioncontext.md:260
msgid ""
"[getX509Certificate()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-"
"shim.ClientIdentity.html#getX509Certificate__anchor) returns the full "
"X.509 certificate of the transaction submitter, including all its "
"attributes and their values. See interaction point **(6)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:263
msgid ""
"[getAttributeValue()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-"
"shim.ClientIdentity.html#getAttributeValue__anchor) returns the value of "
"a particular X.509 attribute, for example, the organizational unit `OU`, "
"or distinguished name `DN`. See interaction point **(6)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:267
msgid ""
"[assertAttributeValue()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-"
"shim.ClientIdentity.html#assertAttributeValue__anchor) returns `TRUE` if "
"the specified attribute of the X.509 attribute has a specified value. See"
" interaction point **(6)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:270
msgid ""
"[getID()](https://hyperledger.github.io/fabric-chaincode-node/master/api"
"/fabric-shim.ClientIdentity.html#getID__anchor) returns the unique "
"identity of the transaction submitter, according to their distinguished "
"name and the issuing CA's distinguished name. The format is "
"`x509::{subject DN}::{issuer DN}`. See interaction point **(6)**."
msgstr ""

#: ../../source/developapps/transactioncontext.md:274
msgid ""
"[getMSPID()](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-shim.ClientIdentity.html#getMSPID__anchor) returns"
" the channel MSP of the transaction submitter. This allows a smart "
"contract to make processing decisions based on the submitter's "
"organizational identity. See interaction point **(15)** or **(16)**."
msgstr ""

#: ../../source/developapps/transactionhandler.md:1
msgid "# Transaction handlers"
msgstr ""

#: ../../source/developapps/transactionhandler.md:5
msgid ""
"Transaction handlers allow smart contract developers to define common "
"processing at key points during the interaction between an application "
"and a smart contract. Transaction handlers are optional but, if defined, "
"they will receive control before or after every transaction in a smart "
"contract is invoked. There is also a specific handler which receives "
"control when a request is made to invoke a transaction not defined in a "
"smart contract."
msgstr ""

#: ../../source/developapps/transactionhandler.md:12
msgid ""
"Here's an example of transaction handlers for the [commercial paper smart"
" contract sample](./smartcontract.html):"
msgstr ""

#: ../../source/developapps/transactionhandler.md:15
msgid "![develop.transactionhandler](./develop.diagram.2.png)"
msgstr ""

#: ../../source/developapps/transactionhandler.md:17
msgid ""
"*Before, After and Unknown transaction handlers. In this example, "
"`beforeTransaction()` is called before the **issue**, **buy** and "
"**redeem** transactions. `afterTransaction()` is called after the "
"**issue**, **buy** and **redeem** transactions. `unknownTransaction()` is"
" only called if a request is made to invoke a transaction not defined in "
"the smart contract.  (The diagram is simplified by not repeating "
"`beforeTransaction` and `afterTransaction` boxes for each transaction.)*"
msgstr ""

#: ../../source/developapps/transactionhandler.md:25
msgid "## Types of handler"
msgstr ""

#: ../../source/developapps/transactionhandler.md:27
msgid ""
"There are three types of transaction handlers which cover different "
"aspects of the interaction between an application and a smart contract:"
msgstr ""

#: ../../source/developapps/transactionhandler.md:30
msgid ""
"**Before handler**: is called before every smart contract transaction is "
"invoked. The handler will usually modify the transaction context to be "
"used by the transaction. The handler has access to the full range of "
"Fabric APIs; for example, it can issue `getState()` and `putState()`."
msgstr ""

#: ../../source/developapps/transactionhandler.md:36
msgid ""
"**After handler**: is called after every smart contract transaction is "
"invoked. The handler will usually perform post-processing common to all "
"transactions, and also has full access to the Fabric APIs."
msgstr ""

#: ../../source/developapps/transactionhandler.md:41
msgid ""
"**Unknown handler**: is called if an attempt is made to invoke a "
"transaction that is not defined in a smart contract. Typically, the "
"handler will record the failure for subsequent processing by an "
"administrator. The handler has full access to the Fabric APIs."
msgstr ""

#: ../../source/developapps/transactionhandler.md:46
msgid ""
"Defining a transaction handler is optional; a smart contract will perform"
" correctly without handlers being defined. A smart contract can define at"
" most one handler of each type."
msgstr ""

#: ../../source/developapps/transactionhandler.md:50
msgid "## Defining a handler"
msgstr ""

#: ../../source/developapps/transactionhandler.md:52
msgid ""
"Transaction handlers are added to the smart contract as methods with well"
" defined names.  Here's an example which adds a handler of each type:"
msgstr ""

#: ../../source/developapps/transactionhandler.md:55
msgid "```JavaScript CommercialPaperContract extends Contract {"
msgstr ""

#: ../../source/developapps/transactionhandler.md:58
msgid "..."
msgstr ""

#: ../../source/developapps/transactionhandler.md:61
msgid "async beforeTransaction(ctx) {"
msgstr ""

#: ../../source/developapps/transactionhandler.md:61
msgid ""
"// Write the transaction ID as an informational to the console "
"console.info(ctx.stub.getTxID());"
msgstr ""

#: ../../source/developapps/transactionhandler.md:66
msgid "async afterTransaction(ctx, result) {"
msgstr ""

#: ../../source/developapps/transactionhandler.md:66
msgid "// This handler interacts with the ledger ctx.stub.cpList.putState(...);"
msgstr ""

#: ../../source/developapps/transactionhandler.md:71
msgid "async unknownTransaction(ctx) {"
msgstr ""

#: ../../source/developapps/transactionhandler.md:71
msgid ""
"// This handler throws an exception throw new Error('Unknown transaction "
"function');"
msgstr ""

#: ../../source/developapps/transactionhandler.md:78
msgid ""
"The form of a transaction handler definition is the similar for all "
"handler types, but notice how the `afterTransaction(ctx, result)` also "
"receives any result returned by the transaction. The [API "
"documentation](https://hyperledger.github.io/fabric-chaincode-"
"node/master/api/fabric-contract-api.Contract.html) shows you the exact "
"form of these handlers."
msgstr ""

#: ../../source/developapps/transactionhandler.md:84
msgid "## Handler processing"
msgstr ""

#: ../../source/developapps/transactionhandler.md:86
msgid ""
"Once a handler has been added to the smart contract, it will be invoked "
"during transaction processing. During processing, the handler receives "
"`ctx`, the [transaction context](./transationcontext.md), performs some "
"processing, and returns control as it completes. Processing continues as "
"follows:"
msgstr ""

#: ../../source/developapps/transactionhandler.md:91
msgid ""
"**Before handler**: If the handler completes successfully, the "
"transaction is called with the updated context. If the handler throws an "
"exception, then the transaction is not called and the smart contract "
"fails with the exception error message."
msgstr ""

#: ../../source/developapps/transactionhandler.md:97
msgid ""
"**After handler**: If the handler completes successfully, then the smart "
"contract completes as determined by the invoked transaction. If the "
"handler throws an exception, then the transaction fails with the "
"exception error message."
msgstr ""

#: ../../source/developapps/transactionhandler.md:103
msgid ""
"**Unknown handler**: The handler should complete by throwing an exception"
" with the required error message. If an **Unknown handler** is not "
"specified, or an exception is not thrown by it, there is sensible default"
" processing; the smart contract will fail with an **unknown transaction**"
" error message."
msgstr ""

#: ../../source/developapps/transactionhandler.md:108
msgid ""
"If the handler requires access to the function and parameters, then it is"
" easy to do this:"
msgstr ""

#: ../../source/developapps/transactionhandler.md:110
msgid "```JavaScript async beforeTransaction(ctx) {"
msgstr ""

#: ../../source/developapps/transactionhandler.md:112
msgid ""
"// Retrieve details of the transaction let txnDetails = "
"ctx.stub.getFunctionAndParameters();"
msgstr ""

#: ../../source/developapps/transactionhandler.md:115
msgid ""
"console.info(`Calling function: ${txnDetails.fcn} `); "
"console.info(util.format(`Function arguments : %j ${stub.getArgs()} ``);"
msgstr ""

#: ../../source/developapps/transactionhandler.md:120
msgid ""
"See how this handler uses the utility API `getFunctionAndParameters` via "
"the [transaction context](./transactioncontext.html#stub)."
msgstr ""

#: ../../source/developapps/transactionhandler.md:123
msgid "## Multiple handlers"
msgstr ""

#: ../../source/developapps/transactionhandler.md:125
msgid ""
"It is only possible to define at most one handler of each type for a "
"smart contract. If a smart contract needs to invoke multiple functions "
"during before, after or unknown handling, it should coordinate this from "
"within the appropriate function."
msgstr ""

#: ../../source/developapps/wallet.md:1
msgid "# Wallet"
msgstr ""

#: ../../source/developapps/wallet.md:5
msgid ""
"A wallet contains a set of user identities. An application run by a user "
"selects one of these identities when it connects to a channel. Access "
"rights to channel resources, such as the ledger, are determined using "
"this identity in combination with an MSP."
msgstr ""

#: ../../source/developapps/wallet.md:12
msgid "[Why wallets are important](#scenario)"
msgstr ""

#: ../../source/developapps/wallet.md:13
msgid "[How wallets are organized](#structure)"
msgstr ""

#: ../../source/developapps/wallet.md:14
msgid "[Different types of wallet](#types)"
msgstr ""

#: ../../source/developapps/wallet.md:15
msgid "[Wallet operations](#operations)"
msgstr ""

#: ../../source/developapps/wallet.md:19
msgid ""
"When an application connects to a network channel such as PaperNet, it "
"selects a user identity to do so, for example `ID1`. The channel MSPs "
"associate `ID1` with a role within a particular organization, and this "
"role will ultimately determine the application's rights over channel "
"resources. For example, `ID1` might identify a user as a member of the "
"MagnetoCorp organization who can read and write to the ledger, whereas "
"`ID2` might identify an administrator in MagnetoCorp who can add a new "
"organization to a consortium."
msgstr ""

#: ../../source/developapps/wallet.md:27
msgid ""
"![wallet.scenario](./develop.diagram.10.png) *Two users, Isabella and "
"Balaji have wallets containing different identities they can use to "
"connect to different network channels, PaperNet and BondNet.*"
msgstr ""

#: ../../source/developapps/wallet.md:31
msgid ""
"Consider the example of two users; Isabella from MagnetoCorp and Balaji "
"from DigiBank.  Isabella is going to use App 1 to invoke a smart contract"
" in PaperNet and a different smart contract in BondNet.  Similarly, "
"Balaji is going to use App 2 to invoke smart contracts, but only in "
"PaperNet. (It's very [easy](./application.html#construct-request) for "
"applications to access multiple networks and multiple smart contracts "
"within them.)"
msgstr ""

#: ../../source/developapps/wallet.md:38
msgid "See how:"
msgstr ""

#: ../../source/developapps/wallet.md:40
msgid ""
"MagnetoCorp uses CA1 to issue identities and DigiBank uses CA2 to issue "
"identities. These identities are stored in user wallets."
msgstr ""

#: ../../source/developapps/wallet.md:43
msgid ""
"Balaji's wallet holds a single identity, `ID4` issued by CA2. Isabella's "
"wallet has many identities, `ID1`, `ID2` and `ID3`, issued by CA1. "
"Wallets can hold multiple identities for a single user, and each identity"
" can be issued by a different CA."
msgstr ""

#: ../../source/developapps/wallet.md:48
msgid ""
"Both Isabella and Balaji connect to PaperNet, and its MSPs determine that"
" Isabella is a member of the MagnetoCorp organization, and Balaji is a "
"member of the DigiBank organization, because of the respective CAs that "
"issued their identities. (It is [possible](../membership/membership.html"
"#mapping-msps-to-organizations) for an organization to use multiple CAs, "
"and for a single CA to support multiple organizations.)"
msgstr ""

#: ../../source/developapps/wallet.md:56
msgid ""
"Isabella can use `ID1` to connect to both PaperNet and BondNet. In both "
"cases, when Isabella uses this identity, she is recognized as a member of"
" MangetoCorp."
msgstr ""

#: ../../source/developapps/wallet.md:60
msgid ""
"Isabella can use `ID2` to connect to BondNet, in which case she is "
"identified as an administrator of MagnetoCorp. This gives Isabella two "
"very different privileges: `ID1` identifies her as a simple member of "
"MagnetoCorp who can read and write to the BondNet ledger, whereas `ID2` "
"identities her as a MagnetoCorp administrator who can add a new "
"organization to BondNet."
msgstr ""

#: ../../source/developapps/wallet.md:66
msgid ""
"Balaji cannot connect to BondNet with `ID4`. If he tried to connect, "
"`ID4` would not be recognized as belonging to DigiBank because CA2 is not"
" known to BondNet's MSP."
msgstr ""

#: ../../source/developapps/wallet.md:70
msgid "## Types"
msgstr ""

#: ../../source/developapps/wallet.md:72
msgid ""
"There are different types of wallets according to where they store their "
"identities:"
msgstr ""

#: ../../source/developapps/wallet.md:75
msgid ""
"![wallet.types](./develop.diagram.12.png) *The three different types of "
"wallet storage: File system, In-memory and CouchDB.*"
msgstr ""

#: ../../source/developapps/wallet.md:78
msgid ""
"**File system**: This is the most common place to store wallets; file "
"systems are pervasive, easy to understand, and can be network mounted. "
"They are a good default choice for wallets."
msgstr ""

#: ../../source/developapps/wallet.md:82
msgid ""
"**In-memory**: A wallet in application storage. Use this type of wallet "
"when your application is running in a constrained environment without "
"access to a file system; typically a web browser. It's worth remembering "
"that this type of wallet is volatile; identities will be lost after the "
"application ends normally or crashes."
msgstr ""

#: ../../source/developapps/wallet.md:88
msgid ""
"**CouchDB**: A wallet stored in CouchDB. This is the rarest form of "
"wallet storage, but for those users who want to use the database back-up "
"and restore mechanisms, CouchDB wallets can provide a useful option to "
"simplify disaster recovery."
msgstr ""

#: ../../source/developapps/wallet.md:93
msgid ""
"Use factory functions provided by the `Wallets` "
"[class](https://hyperledger.github.io/fabric-sdk-node/master/module-"
"fabric-network.Wallets.html) to create wallets."
msgstr ""

#: ../../source/developapps/wallet.md:97
msgid "### Hardware Security Module"
msgstr ""

#: ../../source/developapps/wallet.md:99
msgid ""
"A Hardware Security Module (HSM) is an ultra-secure, tamper-proof device "
"that stores digital identity information, particularly private keys. HSMs"
" can be locally attached to your computer or network accessible. Most "
"HSMs provide the ability to perform on-board encryption with private "
"keys, such that the private keys never leave the HSM."
msgstr ""

#: ../../source/developapps/wallet.md:105
msgid ""
"An HSM can be used with any of the wallet types. In this case the "
"certificate for an identity will be stored in the wallet and the private "
"key will be stored in the HSM."
msgstr ""

#: ../../source/developapps/wallet.md:109
msgid ""
"To enable the use of HSM-managed identities, an `IdentityProvider` must "
"be configured with the HSM connection information and registered with the"
" wallet. For further details, refer to the [Using wallets to manage "
"identities](https://hyperledger.github.io/fabric-sdk-node/master"
"/tutorial-wallet.html) tutorial."
msgstr ""

#: ../../source/developapps/wallet.md:115
msgid ""
"A single wallet can hold multiple identities, each issued by a particular"
" Certificate Authority. Each identity has a standard structure comprising"
" a descriptive label, an X.509 certificate containing a public key, a "
"private key, and some Fabric-specific metadata. Different [wallet "
"types](#types) map this structure appropriately to their storage "
"mechanism."
msgstr ""

#: ../../source/developapps/wallet.md:121
msgid ""
"![wallet.structure](./develop.diagram.11.png) *A Fabric wallet can hold "
"multiple identities with certificates issued by a different Certificate "
"Authority. Identities comprise certificate, private key and Fabric "
"metadata.*"
msgstr ""

#: ../../source/developapps/wallet.md:125
msgid ""
"There's a couple of key class methods that make it easy to manage wallets"
" and identities:"
msgstr ""

#: ../../source/developapps/wallet.md:128
msgid "```JavaScript const identity: X509Identity = {"
msgstr ""

#: ../../source/developapps/wallet.md:131
#: ../../source/developapps/wallet.md:202
msgid "credentials: {"
msgstr ""

#: ../../source/developapps/wallet.md:131
msgid "certificate: certificatePEM, privateKey: privateKeyPEM,"
msgstr ""

#: ../../source/developapps/wallet.md:133
#: ../../source/developapps/wallet.md:204
msgid "}, mspId: 'Org1MSP', type: 'X.509',"
msgstr ""

#: ../../source/developapps/wallet.md:136
msgid "}; await wallet.put(identityLabel, identity); ```"
msgstr ""

#: ../../source/developapps/wallet.md:140
msgid ""
"See how an `identity` is created that has metadata `Org1MSP`, a "
"`certificate` and a `privateKey`. See how `wallet.put()` adds this "
"identity to the wallet with a particular `identityLabel`."
msgstr ""

#: ../../source/developapps/wallet.md:144
msgid ""
"The `Gateway` class only requires the `mspId` and `type` metadata to be "
"set for an identity -- `Org1MSP` and `X.509` in the above example. It "
"*currently* uses the MSP ID value to identify particular peers from a "
"[connection profile](./connectionprofile.html), for example when a "
"specific notification [strategy](./connectoptions.html) is requested. In "
"the DigiBank gateway file `networkConnection.yaml`, see how `Org1MSP` "
"notifications will be associated with `peer0.org1.example.com`:"
msgstr ""

#: ../../source/developapps/wallet.md:151
msgid "```yaml organizations:"
msgstr ""

#: ../../source/developapps/wallet.md:156
msgid "Org1:"
msgstr ""

#: ../../source/developapps/wallet.md:154
msgid "mspid: Org1MSP"
msgstr ""

#: ../../source/developapps/wallet.md:157
msgid "peer0.org1.example.com"
msgstr ""

#: ../../source/developapps/wallet.md:160
msgid ""
"You really don't need to worry about the internal structure of the "
"different wallet types, but if you're interested, navigate to a user "
"identity folder in the commercial paper sample:"
msgstr ""

#: ../../source/developapps/wallet.md:164
msgid "``` magnetocorp/identity/user/isabella/"
msgstr ""

#: ../../source/developapps/wallet.md:166
msgid "wallet/"
msgstr ""

#: ../../source/developapps/wallet.md:167
msgid "User1@org1.example.com.id"
msgstr ""

#: ../../source/developapps/wallet.md:170
msgid ""
"You can examine these files, but as discussed, it's easier to use the SDK"
" to manipulate these data."
msgstr ""

#: ../../source/developapps/wallet.md:173
msgid "## Operations"
msgstr ""

#: ../../source/developapps/wallet.md:175
msgid ""
"The different wallet types all implement a common "
"[Wallet](https://hyperledger.github.io/fabric-sdk-node/master/module-"
"fabric-network.Wallet.html) interface which provides a standard set of "
"APIs to manage identities. It means that applications can be made "
"independent of the underlying wallet storage mechanism; for example, File"
" system and HSM wallets are handled in a very similar way."
msgstr ""

#: ../../source/developapps/wallet.md:182
msgid ""
"![wallet.operations](./develop.diagram.13.png) *Wallets follow a "
"lifecycle: they can be created or opened, and identities can be read, "
"added and deleted.*"
msgstr ""

#: ../../source/developapps/wallet.md:186
msgid ""
"An application can use a wallet according to a simple lifecycle. Wallets "
"can be opened or created, and subsequently identities can be added, "
"updated, read and deleted. Spend a little time on the different `Wallet` "
"methods in the [JSDoc](https://hyperledger.github.io/fabric-sdk-"
"node/master/module-fabric-network.Wallet.html) to see how they work; the "
"commercial paper tutorial provides a nice example in `addToWallet.js`:"
msgstr ""

#: ../../source/developapps/wallet.md:193
msgid ""
"```JavaScript const wallet = await "
"Wallets.newFileSystemWallet('../identity/user/isabella/wallet');"
msgstr ""

#: ../../source/developapps/wallet.md:196
msgid ""
"const cert = fs.readFileSync(path.join(credPath, '.../User1@org1.example"
".com-cert.pem')).toString(); const key = "
"fs.readFileSync(path.join(credPath, '.../_sk')).toString();"
msgstr ""

#: ../../source/developapps/wallet.md:199
msgid "const identityLabel = 'User1@org1.example.com'; const identity = {"
msgstr ""

#: ../../source/developapps/wallet.md:202
msgid "certificate: cert, privateKey: key,"
msgstr ""

#: ../../source/developapps/wallet.md:209
msgid "await wallet.put(identityLabel, identity); ```"
msgstr ""

#: ../../source/developapps/wallet.md:214
msgid ""
"When the program is first run, a wallet is created on the local file "
"system at `.../isabella/wallet`."
msgstr ""

#: ../../source/developapps/wallet.md:217
msgid "a certificate `cert` and private `key` are loaded from the file system."
msgstr ""

#: ../../source/developapps/wallet.md:219
msgid "a new X.509 identity is created with `cert`, `key` and `Org1MSP`."
msgstr ""

#: ../../source/developapps/wallet.md:221
msgid ""
"the new identity is added to the wallet with `wallet.put()` with a label "
"`User1@org1.example.com`."
msgstr ""

#: ../../source/developapps/wallet.md:224
msgid ""
"That's everything you need to know about wallets. You've seen how they "
"hold identities that are used by applications on behalf of users to "
"access Fabric network resources. There are different types of wallets "
"available depending on your application and security needs, and a simple "
"set of APIs to help applications manage wallets and the identities within"
" them."
msgstr ""

